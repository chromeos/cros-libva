/* automatically generated by rust-bindgen 0.68.1 */

pub mod constants;

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub type VADisplay = *mut ::std::os::raw::c_void;
pub type VAStatus = ::std::os::raw::c_int;
extern "C" {
    pub fn vaErrorStr(error_status: VAStatus) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VAMotionVector {
    pub mv0: [i16; 2usize],
    pub mv1: [i16; 2usize],
}
pub type VAMotionVector = _VAMotionVector;
pub type VAMessageCallback = ::std::option::Option<
    unsafe extern "C" fn(
        user_context: *mut ::std::os::raw::c_void,
        message: *const ::std::os::raw::c_char,
    ),
>;
extern "C" {
    pub fn vaSetErrorCallback(
        dpy: VADisplay,
        callback: VAMessageCallback,
        user_context: *mut ::std::os::raw::c_void,
    ) -> VAMessageCallback;
}
extern "C" {
    pub fn vaSetInfoCallback(
        dpy: VADisplay,
        callback: VAMessageCallback,
        user_context: *mut ::std::os::raw::c_void,
    ) -> VAMessageCallback;
}
extern "C" {
    pub fn vaDisplayIsValid(dpy: VADisplay) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vaSetDriverName(dpy: VADisplay, driver_name: *mut ::std::os::raw::c_char) -> VAStatus;
}
extern "C" {
    pub fn vaInitialize(
        dpy: VADisplay,
        major_version: *mut ::std::os::raw::c_int,
        minor_version: *mut ::std::os::raw::c_int,
    ) -> VAStatus;
}
extern "C" {
    pub fn vaTerminate(dpy: VADisplay) -> VAStatus;
}
extern "C" {
    pub fn vaQueryVendorString(dpy: VADisplay) -> *const ::std::os::raw::c_char;
}
pub type VAPrivFunc = ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_int>;
extern "C" {
    pub fn vaGetLibFunc(dpy: VADisplay, func: *const ::std::os::raw::c_char) -> VAPrivFunc;
}
pub mod VAProfile {
    pub type Type = ::std::os::raw::c_int;
    pub const VAProfileNone: Type = -1;
    pub const VAProfileMPEG2Simple: Type = 0;
    pub const VAProfileMPEG2Main: Type = 1;
    pub const VAProfileMPEG4Simple: Type = 2;
    pub const VAProfileMPEG4AdvancedSimple: Type = 3;
    pub const VAProfileMPEG4Main: Type = 4;
    pub const VAProfileH264Baseline: Type = 5;
    pub const VAProfileH264Main: Type = 6;
    pub const VAProfileH264High: Type = 7;
    pub const VAProfileVC1Simple: Type = 8;
    pub const VAProfileVC1Main: Type = 9;
    pub const VAProfileVC1Advanced: Type = 10;
    pub const VAProfileH263Baseline: Type = 11;
    pub const VAProfileJPEGBaseline: Type = 12;
    pub const VAProfileH264ConstrainedBaseline: Type = 13;
    pub const VAProfileVP8Version0_3: Type = 14;
    pub const VAProfileH264MultiviewHigh: Type = 15;
    pub const VAProfileH264StereoHigh: Type = 16;
    pub const VAProfileHEVCMain: Type = 17;
    pub const VAProfileHEVCMain10: Type = 18;
    pub const VAProfileVP9Profile0: Type = 19;
    pub const VAProfileVP9Profile1: Type = 20;
    pub const VAProfileVP9Profile2: Type = 21;
    pub const VAProfileVP9Profile3: Type = 22;
    pub const VAProfileHEVCMain12: Type = 23;
    pub const VAProfileHEVCMain422_10: Type = 24;
    pub const VAProfileHEVCMain422_12: Type = 25;
    pub const VAProfileHEVCMain444: Type = 26;
    pub const VAProfileHEVCMain444_10: Type = 27;
    pub const VAProfileHEVCMain444_12: Type = 28;
    pub const VAProfileHEVCSccMain: Type = 29;
    pub const VAProfileHEVCSccMain10: Type = 30;
    pub const VAProfileHEVCSccMain444: Type = 31;
    pub const VAProfileAV1Profile0: Type = 32;
    pub const VAProfileAV1Profile1: Type = 33;
    pub const VAProfileHEVCSccMain444_10: Type = 34;
    pub const VAProfileProtected: Type = 35;
}
pub mod VAEntrypoint {
    pub type Type = ::std::os::raw::c_uint;
    pub const VAEntrypointVLD: Type = 1;
    pub const VAEntrypointIZZ: Type = 2;
    pub const VAEntrypointIDCT: Type = 3;
    pub const VAEntrypointMoComp: Type = 4;
    pub const VAEntrypointDeblocking: Type = 5;
    pub const VAEntrypointEncSlice: Type = 6;
    pub const VAEntrypointEncPicture: Type = 7;
    pub const VAEntrypointEncSliceLP: Type = 8;
    pub const VAEntrypointVideoProc: Type = 10;
    pub const VAEntrypointFEI: Type = 11;
    pub const VAEntrypointStats: Type = 12;
    pub const VAEntrypointProtectedTEEComm: Type = 13;
    pub const VAEntrypointProtectedContent: Type = 14;
}
pub mod VAConfigAttribType {
    pub type Type = ::std::os::raw::c_uint;
    pub const VAConfigAttribRTFormat: Type = 0;
    pub const VAConfigAttribSpatialResidual: Type = 1;
    pub const VAConfigAttribSpatialClipping: Type = 2;
    pub const VAConfigAttribIntraResidual: Type = 3;
    pub const VAConfigAttribEncryption: Type = 4;
    pub const VAConfigAttribRateControl: Type = 5;
    pub const VAConfigAttribDecSliceMode: Type = 6;
    pub const VAConfigAttribDecJPEG: Type = 7;
    pub const VAConfigAttribDecProcessing: Type = 8;
    pub const VAConfigAttribEncPackedHeaders: Type = 10;
    pub const VAConfigAttribEncInterlaced: Type = 11;
    pub const VAConfigAttribEncMaxRefFrames: Type = 13;
    pub const VAConfigAttribEncMaxSlices: Type = 14;
    pub const VAConfigAttribEncSliceStructure: Type = 15;
    pub const VAConfigAttribEncMacroblockInfo: Type = 16;
    pub const VAConfigAttribMaxPictureWidth: Type = 18;
    pub const VAConfigAttribMaxPictureHeight: Type = 19;
    pub const VAConfigAttribEncJPEG: Type = 20;
    pub const VAConfigAttribEncQualityRange: Type = 21;
    pub const VAConfigAttribEncQuantization: Type = 22;
    pub const VAConfigAttribEncIntraRefresh: Type = 23;
    pub const VAConfigAttribEncSkipFrame: Type = 24;
    pub const VAConfigAttribEncROI: Type = 25;
    pub const VAConfigAttribEncRateControlExt: Type = 26;
    pub const VAConfigAttribProcessingRate: Type = 27;
    pub const VAConfigAttribEncDirtyRect: Type = 28;
    pub const VAConfigAttribEncParallelRateControl: Type = 29;
    pub const VAConfigAttribEncDynamicScaling: Type = 30;
    pub const VAConfigAttribFrameSizeToleranceSupport: Type = 31;
    pub const VAConfigAttribFEIFunctionType: Type = 32;
    pub const VAConfigAttribFEIMVPredictors: Type = 33;
    pub const VAConfigAttribStats: Type = 34;
    pub const VAConfigAttribEncTileSupport: Type = 35;
    pub const VAConfigAttribCustomRoundingControl: Type = 36;
    pub const VAConfigAttribQPBlockSize: Type = 37;
    pub const VAConfigAttribMaxFrameSize: Type = 38;
    pub const VAConfigAttribPredictionDirection: Type = 39;
    pub const VAConfigAttribMultipleFrame: Type = 40;
    pub const VAConfigAttribContextPriority: Type = 41;
    pub const VAConfigAttribDecAV1Features: Type = 42;
    pub const VAConfigAttribTEEType: Type = 43;
    pub const VAConfigAttribTEETypeClient: Type = 44;
    pub const VAConfigAttribProtectedContentCipherAlgorithm: Type = 45;
    pub const VAConfigAttribProtectedContentCipherBlockSize: Type = 46;
    pub const VAConfigAttribProtectedContentCipherMode: Type = 47;
    pub const VAConfigAttribProtectedContentCipherSampleType: Type = 48;
    pub const VAConfigAttribProtectedContentUsage: Type = 49;
    pub const VAConfigAttribEncHEVCFeatures: Type = 50;
    pub const VAConfigAttribEncHEVCBlockSizes: Type = 51;
    pub const VAConfigAttribEncAV1: Type = 52;
    pub const VAConfigAttribEncAV1Ext1: Type = 53;
    pub const VAConfigAttribEncAV1Ext2: Type = 54;
    pub const VAConfigAttribEncPerBlockControl: Type = 55;
    pub const VAConfigAttribTypeMax: Type = 56;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _VAConfigAttrib {
    pub type_: VAConfigAttribType::Type,
    pub value: u32,
}
impl Default for _VAConfigAttrib {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type VAConfigAttrib = _VAConfigAttrib;
extern "C" {
    pub fn vaMaxNumProfiles(dpy: VADisplay) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vaMaxNumEntrypoints(dpy: VADisplay) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vaMaxNumConfigAttributes(dpy: VADisplay) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vaQueryConfigProfiles(
        dpy: VADisplay,
        profile_list: *mut VAProfile::Type,
        num_profiles: *mut ::std::os::raw::c_int,
    ) -> VAStatus;
}
extern "C" {
    pub fn vaQueryConfigEntrypoints(
        dpy: VADisplay,
        profile: VAProfile::Type,
        entrypoint_list: *mut VAEntrypoint::Type,
        num_entrypoints: *mut ::std::os::raw::c_int,
    ) -> VAStatus;
}
extern "C" {
    pub fn vaGetConfigAttributes(
        dpy: VADisplay,
        profile: VAProfile::Type,
        entrypoint: VAEntrypoint::Type,
        attrib_list: *mut VAConfigAttrib,
        num_attribs: ::std::os::raw::c_int,
    ) -> VAStatus;
}
pub type VAGenericID = ::std::os::raw::c_uint;
pub type VAConfigID = VAGenericID;
extern "C" {
    pub fn vaCreateConfig(
        dpy: VADisplay,
        profile: VAProfile::Type,
        entrypoint: VAEntrypoint::Type,
        attrib_list: *mut VAConfigAttrib,
        num_attribs: ::std::os::raw::c_int,
        config_id: *mut VAConfigID,
    ) -> VAStatus;
}
extern "C" {
    pub fn vaDestroyConfig(dpy: VADisplay, config_id: VAConfigID) -> VAStatus;
}
extern "C" {
    pub fn vaQueryConfigAttributes(
        dpy: VADisplay,
        config_id: VAConfigID,
        profile: *mut VAProfile::Type,
        entrypoint: *mut VAEntrypoint::Type,
        attrib_list: *mut VAConfigAttrib,
        num_attribs: *mut ::std::os::raw::c_int,
    ) -> VAStatus;
}
pub type VAContextID = VAGenericID;
pub type VASurfaceID = VAGenericID;
pub mod VAGenericValueType {
    pub type Type = ::std::os::raw::c_uint;
    pub const VAGenericValueTypeInteger: Type = 1;
    pub const VAGenericValueTypeFloat: Type = 2;
    pub const VAGenericValueTypePointer: Type = 3;
    pub const VAGenericValueTypeFunc: Type = 4;
}
pub type VAGenericFunc = ::std::option::Option<unsafe extern "C" fn()>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _VAGenericValue {
    pub type_: VAGenericValueType::Type,
    pub value: _VAGenericValue__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _VAGenericValue__bindgen_ty_1 {
    pub i: i32,
    pub f: f32,
    pub p: *mut ::std::os::raw::c_void,
    pub fn_: VAGenericFunc,
}
impl Default for _VAGenericValue__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _VAGenericValue {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type VAGenericValue = _VAGenericValue;
pub mod VASurfaceAttribType {
    pub type Type = ::std::os::raw::c_uint;
    pub const VASurfaceAttribNone: Type = 0;
    pub const VASurfaceAttribPixelFormat: Type = 1;
    pub const VASurfaceAttribMinWidth: Type = 2;
    pub const VASurfaceAttribMaxWidth: Type = 3;
    pub const VASurfaceAttribMinHeight: Type = 4;
    pub const VASurfaceAttribMaxHeight: Type = 5;
    pub const VASurfaceAttribMemoryType: Type = 6;
    pub const VASurfaceAttribExternalBufferDescriptor: Type = 7;
    pub const VASurfaceAttribUsageHint: Type = 8;
    pub const VASurfaceAttribDRMFormatModifiers: Type = 9;
    pub const VASurfaceAttribCount: Type = 10;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _VASurfaceAttrib {
    pub type_: VASurfaceAttribType::Type,
    pub flags: u32,
    pub value: VAGenericValue,
}
impl Default for _VASurfaceAttrib {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type VASurfaceAttrib = _VASurfaceAttrib;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _VASurfaceAttribExternalBuffers {
    pub pixel_format: u32,
    pub width: u32,
    pub height: u32,
    pub data_size: u32,
    pub num_planes: u32,
    pub pitches: [u32; 4usize],
    pub offsets: [u32; 4usize],
    pub buffers: *mut usize,
    pub num_buffers: u32,
    pub flags: u32,
    pub private_data: *mut ::std::os::raw::c_void,
}
impl Default for _VASurfaceAttribExternalBuffers {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type VASurfaceAttribExternalBuffers = _VASurfaceAttribExternalBuffers;
extern "C" {
    pub fn vaQuerySurfaceAttributes(
        dpy: VADisplay,
        config: VAConfigID,
        attrib_list: *mut VASurfaceAttrib,
        num_attribs: *mut ::std::os::raw::c_uint,
    ) -> VAStatus;
}
extern "C" {
    pub fn vaCreateSurfaces(
        dpy: VADisplay,
        format: ::std::os::raw::c_uint,
        width: ::std::os::raw::c_uint,
        height: ::std::os::raw::c_uint,
        surfaces: *mut VASurfaceID,
        num_surfaces: ::std::os::raw::c_uint,
        attrib_list: *mut VASurfaceAttrib,
        num_attribs: ::std::os::raw::c_uint,
    ) -> VAStatus;
}
extern "C" {
    pub fn vaDestroySurfaces(
        dpy: VADisplay,
        surfaces: *mut VASurfaceID,
        num_surfaces: ::std::os::raw::c_int,
    ) -> VAStatus;
}
extern "C" {
    pub fn vaCreateContext(
        dpy: VADisplay,
        config_id: VAConfigID,
        picture_width: ::std::os::raw::c_int,
        picture_height: ::std::os::raw::c_int,
        flag: ::std::os::raw::c_int,
        render_targets: *mut VASurfaceID,
        num_render_targets: ::std::os::raw::c_int,
        context: *mut VAContextID,
    ) -> VAStatus;
}
extern "C" {
    pub fn vaDestroyContext(dpy: VADisplay, context: VAContextID) -> VAStatus;
}
pub type VAMFContextID = VAGenericID;
extern "C" {
    pub fn vaCreateMFContext(dpy: VADisplay, mf_context: *mut VAMFContextID) -> VAStatus;
}
extern "C" {
    pub fn vaMFAddContext(
        dpy: VADisplay,
        mf_context: VAMFContextID,
        context: VAContextID,
    ) -> VAStatus;
}
extern "C" {
    pub fn vaMFReleaseContext(
        dpy: VADisplay,
        mf_context: VAMFContextID,
        context: VAContextID,
    ) -> VAStatus;
}
pub type VABufferID = VAGenericID;
pub mod VABufferType {
    pub type Type = ::std::os::raw::c_uint;
    pub const VAPictureParameterBufferType: Type = 0;
    pub const VAIQMatrixBufferType: Type = 1;
    pub const VABitPlaneBufferType: Type = 2;
    pub const VASliceGroupMapBufferType: Type = 3;
    pub const VASliceParameterBufferType: Type = 4;
    pub const VASliceDataBufferType: Type = 5;
    pub const VAMacroblockParameterBufferType: Type = 6;
    pub const VAResidualDataBufferType: Type = 7;
    pub const VADeblockingParameterBufferType: Type = 8;
    pub const VAImageBufferType: Type = 9;
    pub const VAProtectedSliceDataBufferType: Type = 10;
    pub const VAQMatrixBufferType: Type = 11;
    pub const VAHuffmanTableBufferType: Type = 12;
    pub const VAProbabilityBufferType: Type = 13;
    pub const VAEncCodedBufferType: Type = 21;
    pub const VAEncSequenceParameterBufferType: Type = 22;
    pub const VAEncPictureParameterBufferType: Type = 23;
    pub const VAEncSliceParameterBufferType: Type = 24;
    pub const VAEncPackedHeaderParameterBufferType: Type = 25;
    pub const VAEncPackedHeaderDataBufferType: Type = 26;
    pub const VAEncMiscParameterBufferType: Type = 27;
    pub const VAEncMacroblockParameterBufferType: Type = 28;
    pub const VAEncMacroblockMapBufferType: Type = 29;
    pub const VAEncQPBufferType: Type = 30;
    pub const VAProcPipelineParameterBufferType: Type = 41;
    pub const VAProcFilterParameterBufferType: Type = 42;
    pub const VAEncFEIMVBufferType: Type = 43;
    pub const VAEncFEIMBCodeBufferType: Type = 44;
    pub const VAEncFEIDistortionBufferType: Type = 45;
    pub const VAEncFEIMBControlBufferType: Type = 46;
    pub const VAEncFEIMVPredictorBufferType: Type = 47;
    pub const VAStatsStatisticsParameterBufferType: Type = 48;
    pub const VAStatsStatisticsBufferType: Type = 49;
    pub const VAStatsStatisticsBottomFieldBufferType: Type = 50;
    pub const VAStatsMVBufferType: Type = 51;
    pub const VAStatsMVPredictorBufferType: Type = 52;
    pub const VAEncMacroblockDisableSkipMapBufferType: Type = 53;
    pub const VAEncFEICTBCmdBufferType: Type = 54;
    pub const VAEncFEICURecordBufferType: Type = 55;
    pub const VADecodeStreamoutBufferType: Type = 56;
    pub const VASubsetsParameterBufferType: Type = 57;
    pub const VAContextParameterUpdateBufferType: Type = 58;
    pub const VAProtectedSessionExecuteBufferType: Type = 59;
    pub const VAEncryptionParameterBufferType: Type = 60;
    pub const VAEncDeltaQpPerBlockBufferType: Type = 61;
    pub const VABufferTypeMax: Type = 62;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VAProcessingRateParameterEnc {
    pub level_idc: u8,
    pub reserved: [u8; 3usize],
    pub quality_level: u32,
    pub intra_period: u32,
    pub ip_period: u32,
}
pub type VAProcessingRateParameterEnc = _VAProcessingRateParameterEnc;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VAProcessingRateParameterDec {
    pub level_idc: u8,
    pub reserved0: [u8; 3usize],
    pub reserved: u32,
}
pub type VAProcessingRateParameterDec = _VAProcessingRateParameterDec;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _VAProcessingRateParameter {
    pub __bindgen_anon_1: _VAProcessingRateParameter__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _VAProcessingRateParameter__bindgen_ty_1 {
    pub proc_buf_enc: VAProcessingRateParameterEnc,
    pub proc_buf_dec: VAProcessingRateParameterDec,
}
impl Default for _VAProcessingRateParameter__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _VAProcessingRateParameter {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type VAProcessingRateParameter = _VAProcessingRateParameter;
extern "C" {
    pub fn vaQueryProcessingRate(
        dpy: VADisplay,
        config: VAConfigID,
        proc_buf: *mut VAProcessingRateParameter,
        processing_rate: *mut ::std::os::raw::c_uint,
    ) -> VAStatus;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _VAPictureParameterBufferMPEG2 {
    pub horizontal_size: u16,
    pub vertical_size: u16,
    pub forward_reference_picture: VASurfaceID,
    pub backward_reference_picture: VASurfaceID,
    pub picture_coding_type: i32,
    pub f_code: i32,
    pub picture_coding_extension: _VAPictureParameterBufferMPEG2__bindgen_ty_1,
    pub va_reserved: [u32; 4usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _VAPictureParameterBufferMPEG2__bindgen_ty_1 {
    pub bits: _VAPictureParameterBufferMPEG2__bindgen_ty_1__bindgen_ty_1,
    pub value: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VAPictureParameterBufferMPEG2__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub __bindgen_padding_0: u16,
}
impl _VAPictureParameterBufferMPEG2__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn intra_dc_precision(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_intra_dc_precision(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn picture_structure(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_picture_structure(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn top_field_first(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_top_field_first(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn frame_pred_frame_dct(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_frame_pred_frame_dct(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn concealment_motion_vectors(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_concealment_motion_vectors(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn q_scale_type(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_q_scale_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn intra_vlc_format(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_intra_vlc_format(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn alternate_scan(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_alternate_scan(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn repeat_first_field(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_repeat_first_field(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn progressive_frame(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_progressive_frame(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_first_field(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_first_field(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        intra_dc_precision: u32,
        picture_structure: u32,
        top_field_first: u32,
        frame_pred_frame_dct: u32,
        concealment_motion_vectors: u32,
        q_scale_type: u32,
        intra_vlc_format: u32,
        alternate_scan: u32,
        repeat_first_field: u32,
        progressive_frame: u32,
        is_first_field: u32,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let intra_dc_precision: u32 = unsafe { ::std::mem::transmute(intra_dc_precision) };
            intra_dc_precision as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let picture_structure: u32 = unsafe { ::std::mem::transmute(picture_structure) };
            picture_structure as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let top_field_first: u32 = unsafe { ::std::mem::transmute(top_field_first) };
            top_field_first as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let frame_pred_frame_dct: u32 = unsafe { ::std::mem::transmute(frame_pred_frame_dct) };
            frame_pred_frame_dct as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let concealment_motion_vectors: u32 =
                unsafe { ::std::mem::transmute(concealment_motion_vectors) };
            concealment_motion_vectors as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let q_scale_type: u32 = unsafe { ::std::mem::transmute(q_scale_type) };
            q_scale_type as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let intra_vlc_format: u32 = unsafe { ::std::mem::transmute(intra_vlc_format) };
            intra_vlc_format as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let alternate_scan: u32 = unsafe { ::std::mem::transmute(alternate_scan) };
            alternate_scan as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let repeat_first_field: u32 = unsafe { ::std::mem::transmute(repeat_first_field) };
            repeat_first_field as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let progressive_frame: u32 = unsafe { ::std::mem::transmute(progressive_frame) };
            progressive_frame as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let is_first_field: u32 = unsafe { ::std::mem::transmute(is_first_field) };
            is_first_field as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _VAPictureParameterBufferMPEG2__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _VAPictureParameterBufferMPEG2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type VAPictureParameterBufferMPEG2 = _VAPictureParameterBufferMPEG2;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _VAIQMatrixBufferMPEG2 {
    pub load_intra_quantiser_matrix: i32,
    pub load_non_intra_quantiser_matrix: i32,
    pub load_chroma_intra_quantiser_matrix: i32,
    pub load_chroma_non_intra_quantiser_matrix: i32,
    pub intra_quantiser_matrix: [u8; 64usize],
    pub non_intra_quantiser_matrix: [u8; 64usize],
    pub chroma_intra_quantiser_matrix: [u8; 64usize],
    pub chroma_non_intra_quantiser_matrix: [u8; 64usize],
    pub va_reserved: [u32; 4usize],
}
impl Default for _VAIQMatrixBufferMPEG2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type VAIQMatrixBufferMPEG2 = _VAIQMatrixBufferMPEG2;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VASliceParameterBufferMPEG2 {
    pub slice_data_size: u32,
    pub slice_data_offset: u32,
    pub slice_data_flag: u32,
    pub macroblock_offset: u32,
    pub slice_horizontal_position: u32,
    pub slice_vertical_position: u32,
    pub quantiser_scale_code: i32,
    pub intra_slice_flag: i32,
    pub va_reserved: [u32; 4usize],
}
pub type VASliceParameterBufferMPEG2 = _VASliceParameterBufferMPEG2;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _VAMacroblockParameterBufferMPEG2 {
    pub macroblock_address: u16,
    pub macroblock_type: u8,
    pub macroblock_modes: _VAMacroblockParameterBufferMPEG2__bindgen_ty_1,
    pub motion_vertical_field_select: u8,
    pub PMV: [[[i16; 2usize]; 2usize]; 2usize],
    pub coded_block_pattern: u16,
    pub num_skipped_macroblocks: u16,
    pub va_reserved: [u32; 4usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _VAMacroblockParameterBufferMPEG2__bindgen_ty_1 {
    pub bits: _VAMacroblockParameterBufferMPEG2__bindgen_ty_1__bindgen_ty_1,
    pub value: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VAMacroblockParameterBufferMPEG2__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl _VAMacroblockParameterBufferMPEG2__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn frame_motion_type(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_frame_motion_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn field_motion_type(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_field_motion_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn dct_type(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dct_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        frame_motion_type: u32,
        field_motion_type: u32,
        dct_type: u32,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let frame_motion_type: u32 = unsafe { ::std::mem::transmute(frame_motion_type) };
            frame_motion_type as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let field_motion_type: u32 = unsafe { ::std::mem::transmute(field_motion_type) };
            field_motion_type as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let dct_type: u32 = unsafe { ::std::mem::transmute(dct_type) };
            dct_type as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _VAMacroblockParameterBufferMPEG2__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _VAMacroblockParameterBufferMPEG2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type VAMacroblockParameterBufferMPEG2 = _VAMacroblockParameterBufferMPEG2;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VAPictureH264 {
    pub picture_id: VASurfaceID,
    pub frame_idx: u32,
    pub flags: u32,
    pub TopFieldOrderCnt: i32,
    pub BottomFieldOrderCnt: i32,
    pub va_reserved: [u32; 4usize],
}
pub type VAPictureH264 = _VAPictureH264;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _VAPictureParameterBufferH264 {
    pub CurrPic: VAPictureH264,
    pub ReferenceFrames: [VAPictureH264; 16usize],
    pub picture_width_in_mbs_minus1: u16,
    pub picture_height_in_mbs_minus1: u16,
    pub bit_depth_luma_minus8: u8,
    pub bit_depth_chroma_minus8: u8,
    pub num_ref_frames: u8,
    pub seq_fields: _VAPictureParameterBufferH264__bindgen_ty_1,
    pub num_slice_groups_minus1: u8,
    pub slice_group_map_type: u8,
    pub slice_group_change_rate_minus1: u16,
    pub pic_init_qp_minus26: i8,
    pub pic_init_qs_minus26: i8,
    pub chroma_qp_index_offset: i8,
    pub second_chroma_qp_index_offset: i8,
    pub pic_fields: _VAPictureParameterBufferH264__bindgen_ty_2,
    pub frame_num: u16,
    pub va_reserved: [u32; 8usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _VAPictureParameterBufferH264__bindgen_ty_1 {
    pub bits: _VAPictureParameterBufferH264__bindgen_ty_1__bindgen_ty_1,
    pub value: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VAPictureParameterBufferH264__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize]>,
    pub __bindgen_padding_0: u8,
}
impl _VAPictureParameterBufferH264__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn chroma_format_idc(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_chroma_format_idc(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn residual_colour_transform_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_residual_colour_transform_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn gaps_in_frame_num_value_allowed_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_gaps_in_frame_num_value_allowed_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn frame_mbs_only_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_frame_mbs_only_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mb_adaptive_frame_field_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mb_adaptive_frame_field_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn direct_8x8_inference_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_direct_8x8_inference_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MinLumaBiPredSize8x8(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MinLumaBiPredSize8x8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn log2_max_frame_num_minus4(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_log2_max_frame_num_minus4(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn pic_order_cnt_type(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_pic_order_cnt_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn log2_max_pic_order_cnt_lsb_minus4(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_log2_max_pic_order_cnt_lsb_minus4(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn delta_pic_order_always_zero_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_delta_pic_order_always_zero_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        chroma_format_idc: u32,
        residual_colour_transform_flag: u32,
        gaps_in_frame_num_value_allowed_flag: u32,
        frame_mbs_only_flag: u32,
        mb_adaptive_frame_field_flag: u32,
        direct_8x8_inference_flag: u32,
        MinLumaBiPredSize8x8: u32,
        log2_max_frame_num_minus4: u32,
        pic_order_cnt_type: u32,
        log2_max_pic_order_cnt_lsb_minus4: u32,
        delta_pic_order_always_zero_flag: u32,
    ) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let chroma_format_idc: u32 = unsafe { ::std::mem::transmute(chroma_format_idc) };
            chroma_format_idc as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let residual_colour_transform_flag: u32 =
                unsafe { ::std::mem::transmute(residual_colour_transform_flag) };
            residual_colour_transform_flag as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let gaps_in_frame_num_value_allowed_flag: u32 =
                unsafe { ::std::mem::transmute(gaps_in_frame_num_value_allowed_flag) };
            gaps_in_frame_num_value_allowed_flag as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let frame_mbs_only_flag: u32 = unsafe { ::std::mem::transmute(frame_mbs_only_flag) };
            frame_mbs_only_flag as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let mb_adaptive_frame_field_flag: u32 =
                unsafe { ::std::mem::transmute(mb_adaptive_frame_field_flag) };
            mb_adaptive_frame_field_flag as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let direct_8x8_inference_flag: u32 =
                unsafe { ::std::mem::transmute(direct_8x8_inference_flag) };
            direct_8x8_inference_flag as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let MinLumaBiPredSize8x8: u32 = unsafe { ::std::mem::transmute(MinLumaBiPredSize8x8) };
            MinLumaBiPredSize8x8 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let log2_max_frame_num_minus4: u32 =
                unsafe { ::std::mem::transmute(log2_max_frame_num_minus4) };
            log2_max_frame_num_minus4 as u64
        });
        __bindgen_bitfield_unit.set(12usize, 2u8, {
            let pic_order_cnt_type: u32 = unsafe { ::std::mem::transmute(pic_order_cnt_type) };
            pic_order_cnt_type as u64
        });
        __bindgen_bitfield_unit.set(14usize, 4u8, {
            let log2_max_pic_order_cnt_lsb_minus4: u32 =
                unsafe { ::std::mem::transmute(log2_max_pic_order_cnt_lsb_minus4) };
            log2_max_pic_order_cnt_lsb_minus4 as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let delta_pic_order_always_zero_flag: u32 =
                unsafe { ::std::mem::transmute(delta_pic_order_always_zero_flag) };
            delta_pic_order_always_zero_flag as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _VAPictureParameterBufferH264__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _VAPictureParameterBufferH264__bindgen_ty_2 {
    pub bits: _VAPictureParameterBufferH264__bindgen_ty_2__bindgen_ty_1,
    pub value: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VAPictureParameterBufferH264__bindgen_ty_2__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub __bindgen_padding_0: u16,
}
impl _VAPictureParameterBufferH264__bindgen_ty_2__bindgen_ty_1 {
    #[inline]
    pub fn entropy_coding_mode_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_entropy_coding_mode_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn weighted_pred_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_weighted_pred_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn weighted_bipred_idc(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_weighted_bipred_idc(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn transform_8x8_mode_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_transform_8x8_mode_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn field_pic_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_field_pic_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn constrained_intra_pred_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_constrained_intra_pred_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pic_order_present_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pic_order_present_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn deblocking_filter_control_present_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_deblocking_filter_control_present_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn redundant_pic_cnt_present_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_redundant_pic_cnt_present_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reference_pic_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reference_pic_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        entropy_coding_mode_flag: u32,
        weighted_pred_flag: u32,
        weighted_bipred_idc: u32,
        transform_8x8_mode_flag: u32,
        field_pic_flag: u32,
        constrained_intra_pred_flag: u32,
        pic_order_present_flag: u32,
        deblocking_filter_control_present_flag: u32,
        redundant_pic_cnt_present_flag: u32,
        reference_pic_flag: u32,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let entropy_coding_mode_flag: u32 =
                unsafe { ::std::mem::transmute(entropy_coding_mode_flag) };
            entropy_coding_mode_flag as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let weighted_pred_flag: u32 = unsafe { ::std::mem::transmute(weighted_pred_flag) };
            weighted_pred_flag as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let weighted_bipred_idc: u32 = unsafe { ::std::mem::transmute(weighted_bipred_idc) };
            weighted_bipred_idc as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let transform_8x8_mode_flag: u32 =
                unsafe { ::std::mem::transmute(transform_8x8_mode_flag) };
            transform_8x8_mode_flag as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let field_pic_flag: u32 = unsafe { ::std::mem::transmute(field_pic_flag) };
            field_pic_flag as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let constrained_intra_pred_flag: u32 =
                unsafe { ::std::mem::transmute(constrained_intra_pred_flag) };
            constrained_intra_pred_flag as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let pic_order_present_flag: u32 =
                unsafe { ::std::mem::transmute(pic_order_present_flag) };
            pic_order_present_flag as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let deblocking_filter_control_present_flag: u32 =
                unsafe { ::std::mem::transmute(deblocking_filter_control_present_flag) };
            deblocking_filter_control_present_flag as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let redundant_pic_cnt_present_flag: u32 =
                unsafe { ::std::mem::transmute(redundant_pic_cnt_present_flag) };
            redundant_pic_cnt_present_flag as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let reference_pic_flag: u32 = unsafe { ::std::mem::transmute(reference_pic_flag) };
            reference_pic_flag as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _VAPictureParameterBufferH264__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _VAPictureParameterBufferH264 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type VAPictureParameterBufferH264 = _VAPictureParameterBufferH264;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _VAIQMatrixBufferH264 {
    pub ScalingList4x4: [[u8; 16usize]; 6usize],
    pub ScalingList8x8: [[u8; 64usize]; 2usize],
    pub va_reserved: [u32; 4usize],
}
impl Default for _VAIQMatrixBufferH264 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type VAIQMatrixBufferH264 = _VAIQMatrixBufferH264;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VASliceParameterBufferH264 {
    pub slice_data_size: u32,
    pub slice_data_offset: u32,
    pub slice_data_flag: u32,
    pub slice_data_bit_offset: u16,
    pub first_mb_in_slice: u16,
    pub slice_type: u8,
    pub direct_spatial_mv_pred_flag: u8,
    pub num_ref_idx_l0_active_minus1: u8,
    pub num_ref_idx_l1_active_minus1: u8,
    pub cabac_init_idc: u8,
    pub slice_qp_delta: i8,
    pub disable_deblocking_filter_idc: u8,
    pub slice_alpha_c0_offset_div2: i8,
    pub slice_beta_offset_div2: i8,
    pub RefPicList0: [VAPictureH264; 32usize],
    pub RefPicList1: [VAPictureH264; 32usize],
    pub luma_log2_weight_denom: u8,
    pub chroma_log2_weight_denom: u8,
    pub luma_weight_l0_flag: u8,
    pub luma_weight_l0: [i16; 32usize],
    pub luma_offset_l0: [i16; 32usize],
    pub chroma_weight_l0_flag: u8,
    pub chroma_weight_l0: [[i16; 2usize]; 32usize],
    pub chroma_offset_l0: [[i16; 2usize]; 32usize],
    pub luma_weight_l1_flag: u8,
    pub luma_weight_l1: [i16; 32usize],
    pub luma_offset_l1: [i16; 32usize],
    pub chroma_weight_l1_flag: u8,
    pub chroma_weight_l1: [[i16; 2usize]; 32usize],
    pub chroma_offset_l1: [[i16; 2usize]; 32usize],
    pub va_reserved: [u32; 4usize],
}
pub type VASliceParameterBufferH264 = _VASliceParameterBufferH264;
pub mod VAEncPictureType {
    pub type Type = ::std::os::raw::c_uint;
    pub const VAEncPictureTypeIntra: Type = 0;
    pub const VAEncPictureTypePredictive: Type = 1;
    pub const VAEncPictureTypeBidirectional: Type = 2;
}
extern "C" {
    pub fn vaCreateBuffer(
        dpy: VADisplay,
        context: VAContextID,
        type_: VABufferType::Type,
        size: ::std::os::raw::c_uint,
        num_elements: ::std::os::raw::c_uint,
        data: *mut ::std::os::raw::c_void,
        buf_id: *mut VABufferID,
    ) -> VAStatus;
}
extern "C" {
    pub fn vaCreateBuffer2(
        dpy: VADisplay,
        context: VAContextID,
        type_: VABufferType::Type,
        width: ::std::os::raw::c_uint,
        height: ::std::os::raw::c_uint,
        unit_size: *mut ::std::os::raw::c_uint,
        pitch: *mut ::std::os::raw::c_uint,
        buf_id: *mut VABufferID,
    ) -> VAStatus;
}
extern "C" {
    pub fn vaBufferSetNumElements(
        dpy: VADisplay,
        buf_id: VABufferID,
        num_elements: ::std::os::raw::c_uint,
    ) -> VAStatus;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _VACodedBufferSegment {
    pub size: u32,
    pub bit_offset: u32,
    pub status: u32,
    pub reserved: u32,
    pub buf: *mut ::std::os::raw::c_void,
    pub next: *mut ::std::os::raw::c_void,
    pub va_reserved: [u32; 4usize],
}
impl Default for _VACodedBufferSegment {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type VACodedBufferSegment = _VACodedBufferSegment;
extern "C" {
    pub fn vaMapBuffer(
        dpy: VADisplay,
        buf_id: VABufferID,
        pbuf: *mut *mut ::std::os::raw::c_void,
    ) -> VAStatus;
}
extern "C" {
    pub fn vaUnmapBuffer(dpy: VADisplay, buf_id: VABufferID) -> VAStatus;
}
extern "C" {
    pub fn vaDestroyBuffer(dpy: VADisplay, buffer_id: VABufferID) -> VAStatus;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct VABufferInfo {
    pub handle: usize,
    pub type_: u32,
    pub mem_type: u32,
    pub mem_size: usize,
    pub va_reserved: [u32; 4usize],
}
extern "C" {
    pub fn vaAcquireBufferHandle(
        dpy: VADisplay,
        buf_id: VABufferID,
        buf_info: *mut VABufferInfo,
    ) -> VAStatus;
}
extern "C" {
    pub fn vaReleaseBufferHandle(dpy: VADisplay, buf_id: VABufferID) -> VAStatus;
}
extern "C" {
    pub fn vaExportSurfaceHandle(
        dpy: VADisplay,
        surface_id: VASurfaceID,
        mem_type: u32,
        flags: u32,
        descriptor: *mut ::std::os::raw::c_void,
    ) -> VAStatus;
}
extern "C" {
    pub fn vaBeginPicture(
        dpy: VADisplay,
        context: VAContextID,
        render_target: VASurfaceID,
    ) -> VAStatus;
}
extern "C" {
    pub fn vaRenderPicture(
        dpy: VADisplay,
        context: VAContextID,
        buffers: *mut VABufferID,
        num_buffers: ::std::os::raw::c_int,
    ) -> VAStatus;
}
extern "C" {
    pub fn vaEndPicture(dpy: VADisplay, context: VAContextID) -> VAStatus;
}
extern "C" {
    pub fn vaMFSubmit(
        dpy: VADisplay,
        mf_context: VAMFContextID,
        contexts: *mut VAContextID,
        num_contexts: ::std::os::raw::c_int,
    ) -> VAStatus;
}
extern "C" {
    pub fn vaSyncSurface(dpy: VADisplay, render_target: VASurfaceID) -> VAStatus;
}
extern "C" {
    pub fn vaSyncSurface2(dpy: VADisplay, surface: VASurfaceID, timeout_ns: u64) -> VAStatus;
}
pub mod VASurfaceStatus {
    pub type Type = ::std::os::raw::c_uint;
    pub const VASurfaceRendering: Type = 1;
    pub const VASurfaceDisplaying: Type = 2;
    pub const VASurfaceReady: Type = 4;
    pub const VASurfaceSkipped: Type = 8;
}
extern "C" {
    pub fn vaQuerySurfaceStatus(
        dpy: VADisplay,
        render_target: VASurfaceID,
        status: *mut VASurfaceStatus::Type,
    ) -> VAStatus;
}
extern "C" {
    pub fn vaQuerySurfaceError(
        dpy: VADisplay,
        surface: VASurfaceID,
        error_status: VAStatus,
        error_info: *mut *mut ::std::os::raw::c_void,
    ) -> VAStatus;
}
extern "C" {
    pub fn vaSyncBuffer(dpy: VADisplay, buf_id: VABufferID, timeout_ns: u64) -> VAStatus;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VAImageFormat {
    pub fourcc: u32,
    pub byte_order: u32,
    pub bits_per_pixel: u32,
    pub depth: u32,
    pub red_mask: u32,
    pub green_mask: u32,
    pub blue_mask: u32,
    pub alpha_mask: u32,
    pub va_reserved: [u32; 4usize],
}
pub type VAImageFormat = _VAImageFormat;
pub type VAImageID = VAGenericID;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VAImage {
    pub image_id: VAImageID,
    pub format: VAImageFormat,
    pub buf: VABufferID,
    pub width: u16,
    pub height: u16,
    pub data_size: u32,
    pub num_planes: u32,
    pub pitches: [u32; 3usize],
    pub offsets: [u32; 3usize],
    pub num_palette_entries: i32,
    pub entry_bytes: i32,
    pub component_order: [i8; 4usize],
    pub va_reserved: [u32; 4usize],
}
pub type VAImage = _VAImage;
extern "C" {
    pub fn vaMaxNumImageFormats(dpy: VADisplay) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vaQueryImageFormats(
        dpy: VADisplay,
        format_list: *mut VAImageFormat,
        num_formats: *mut ::std::os::raw::c_int,
    ) -> VAStatus;
}
extern "C" {
    pub fn vaCreateImage(
        dpy: VADisplay,
        format: *mut VAImageFormat,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        image: *mut VAImage,
    ) -> VAStatus;
}
extern "C" {
    pub fn vaDestroyImage(dpy: VADisplay, image: VAImageID) -> VAStatus;
}
extern "C" {
    pub fn vaSetImagePalette(
        dpy: VADisplay,
        image: VAImageID,
        palette: *mut ::std::os::raw::c_uchar,
    ) -> VAStatus;
}
extern "C" {
    pub fn vaGetImage(
        dpy: VADisplay,
        surface: VASurfaceID,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        width: ::std::os::raw::c_uint,
        height: ::std::os::raw::c_uint,
        image: VAImageID,
    ) -> VAStatus;
}
extern "C" {
    pub fn vaPutImage(
        dpy: VADisplay,
        surface: VASurfaceID,
        image: VAImageID,
        src_x: ::std::os::raw::c_int,
        src_y: ::std::os::raw::c_int,
        src_width: ::std::os::raw::c_uint,
        src_height: ::std::os::raw::c_uint,
        dest_x: ::std::os::raw::c_int,
        dest_y: ::std::os::raw::c_int,
        dest_width: ::std::os::raw::c_uint,
        dest_height: ::std::os::raw::c_uint,
    ) -> VAStatus;
}
extern "C" {
    pub fn vaDeriveImage(dpy: VADisplay, surface: VASurfaceID, image: *mut VAImage) -> VAStatus;
}
pub type VASubpictureID = VAGenericID;
extern "C" {
    pub fn vaMaxNumSubpictureFormats(dpy: VADisplay) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vaQuerySubpictureFormats(
        dpy: VADisplay,
        format_list: *mut VAImageFormat,
        flags: *mut ::std::os::raw::c_uint,
        num_formats: *mut ::std::os::raw::c_uint,
    ) -> VAStatus;
}
extern "C" {
    pub fn vaCreateSubpicture(
        dpy: VADisplay,
        image: VAImageID,
        subpicture: *mut VASubpictureID,
    ) -> VAStatus;
}
extern "C" {
    pub fn vaDestroySubpicture(dpy: VADisplay, subpicture: VASubpictureID) -> VAStatus;
}
extern "C" {
    pub fn vaSetSubpictureImage(
        dpy: VADisplay,
        subpicture: VASubpictureID,
        image: VAImageID,
    ) -> VAStatus;
}
extern "C" {
    pub fn vaSetSubpictureChromakey(
        dpy: VADisplay,
        subpicture: VASubpictureID,
        chromakey_min: ::std::os::raw::c_uint,
        chromakey_max: ::std::os::raw::c_uint,
        chromakey_mask: ::std::os::raw::c_uint,
    ) -> VAStatus;
}
extern "C" {
    pub fn vaSetSubpictureGlobalAlpha(
        dpy: VADisplay,
        subpicture: VASubpictureID,
        global_alpha: f32,
    ) -> VAStatus;
}
extern "C" {
    pub fn vaAssociateSubpicture(
        dpy: VADisplay,
        subpicture: VASubpictureID,
        target_surfaces: *mut VASurfaceID,
        num_surfaces: ::std::os::raw::c_int,
        src_x: i16,
        src_y: i16,
        src_width: u16,
        src_height: u16,
        dest_x: i16,
        dest_y: i16,
        dest_width: u16,
        dest_height: u16,
        flags: u32,
    ) -> VAStatus;
}
extern "C" {
    pub fn vaDeassociateSubpicture(
        dpy: VADisplay,
        subpicture: VASubpictureID,
        target_surfaces: *mut VASurfaceID,
        num_surfaces: ::std::os::raw::c_int,
    ) -> VAStatus;
}
pub mod VADisplayAttribType {
    pub type Type = ::std::os::raw::c_uint;
    pub const VADisplayAttribBrightness: Type = 0;
    pub const VADisplayAttribContrast: Type = 1;
    pub const VADisplayAttribHue: Type = 2;
    pub const VADisplayAttribSaturation: Type = 3;
    pub const VADisplayAttribBackgroundColor: Type = 4;
    pub const VADisplayAttribDirectSurface: Type = 5;
    pub const VADisplayAttribRotation: Type = 6;
    pub const VADisplayAttribOutofLoopDeblock: Type = 7;
    pub const VADisplayAttribBLEBlackMode: Type = 8;
    pub const VADisplayAttribBLEWhiteMode: Type = 9;
    pub const VADisplayAttribBlueStretch: Type = 10;
    pub const VADisplayAttribSkinColorCorrection: Type = 11;
    pub const VADisplayAttribCSCMatrix: Type = 12;
    pub const VADisplayAttribBlendColor: Type = 13;
    pub const VADisplayAttribOverlayAutoPaintColorKey: Type = 14;
    pub const VADisplayAttribOverlayColorKey: Type = 15;
    pub const VADisplayAttribRenderMode: Type = 16;
    pub const VADisplayAttribRenderDevice: Type = 17;
    pub const VADisplayAttribRenderRect: Type = 18;
    pub const VADisplayAttribSubDevice: Type = 19;
    pub const VADisplayAttribCopy: Type = 20;
    pub const VADisplayPCIID: Type = 21;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _VADisplayAttribute {
    pub type_: VADisplayAttribType::Type,
    pub min_value: i32,
    pub max_value: i32,
    pub value: i32,
    pub flags: u32,
    pub va_reserved: [u32; 4usize],
}
impl Default for _VADisplayAttribute {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type VADisplayAttribute = _VADisplayAttribute;
extern "C" {
    pub fn vaMaxNumDisplayAttributes(dpy: VADisplay) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vaQueryDisplayAttributes(
        dpy: VADisplay,
        attr_list: *mut VADisplayAttribute,
        num_attributes: *mut ::std::os::raw::c_int,
    ) -> VAStatus;
}
extern "C" {
    pub fn vaGetDisplayAttributes(
        dpy: VADisplay,
        attr_list: *mut VADisplayAttribute,
        num_attributes: ::std::os::raw::c_int,
    ) -> VAStatus;
}
extern "C" {
    pub fn vaSetDisplayAttributes(
        dpy: VADisplay,
        attr_list: *mut VADisplayAttribute,
        num_attributes: ::std::os::raw::c_int,
    ) -> VAStatus;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VAPictureHEVC {
    pub picture_id: VASurfaceID,
    pub pic_order_cnt: i32,
    pub flags: u32,
    pub va_reserved: [u32; 4usize],
}
pub type VAPictureHEVC = _VAPictureHEVC;
pub mod VACopyObjectType {
    pub type Type = ::std::os::raw::c_uint;
    pub const VACopyObjectSurface: Type = 0;
    pub const VACopyObjectBuffer: Type = 1;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _VACopyObject {
    pub obj_type: VACopyObjectType::Type,
    pub object: _VACopyObject__bindgen_ty_1,
    pub va_reserved: [u32; 8usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _VACopyObject__bindgen_ty_1 {
    pub surface_id: VASurfaceID,
    pub buffer_id: VABufferID,
}
impl Default for _VACopyObject__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _VACopyObject {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type VACopyObject = _VACopyObject;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _VACopyOption {
    pub bits: _VACopyOption__bindgen_ty_1,
    pub value: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VACopyOption__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _VACopyOption__bindgen_ty_1 {
    #[inline]
    pub fn va_copy_sync(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_va_copy_sync(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn va_copy_mode(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_va_copy_mode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 26u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 26u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        va_copy_sync: u32,
        va_copy_mode: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let va_copy_sync: u32 = unsafe { ::std::mem::transmute(va_copy_sync) };
            va_copy_sync as u64
        });
        __bindgen_bitfield_unit.set(2usize, 4u8, {
            let va_copy_mode: u32 = unsafe { ::std::mem::transmute(va_copy_mode) };
            va_copy_mode as u64
        });
        __bindgen_bitfield_unit.set(6usize, 26u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _VACopyOption {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type VACopyOption = _VACopyOption;
extern "C" {
    pub fn vaCopy(
        dpy: VADisplay,
        dst: *mut VACopyObject,
        src: *mut VACopyObject,
        option: VACopyOption,
    ) -> VAStatus;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _VAPictureParameterBufferHEVC {
    pub CurrPic: VAPictureHEVC,
    pub ReferenceFrames: [VAPictureHEVC; 15usize],
    pub pic_width_in_luma_samples: u16,
    pub pic_height_in_luma_samples: u16,
    pub pic_fields: _VAPictureParameterBufferHEVC__bindgen_ty_1,
    pub sps_max_dec_pic_buffering_minus1: u8,
    pub bit_depth_luma_minus8: u8,
    pub bit_depth_chroma_minus8: u8,
    pub pcm_sample_bit_depth_luma_minus1: u8,
    pub pcm_sample_bit_depth_chroma_minus1: u8,
    pub log2_min_luma_coding_block_size_minus3: u8,
    pub log2_diff_max_min_luma_coding_block_size: u8,
    pub log2_min_transform_block_size_minus2: u8,
    pub log2_diff_max_min_transform_block_size: u8,
    pub log2_min_pcm_luma_coding_block_size_minus3: u8,
    pub log2_diff_max_min_pcm_luma_coding_block_size: u8,
    pub max_transform_hierarchy_depth_intra: u8,
    pub max_transform_hierarchy_depth_inter: u8,
    pub init_qp_minus26: i8,
    pub diff_cu_qp_delta_depth: u8,
    pub pps_cb_qp_offset: i8,
    pub pps_cr_qp_offset: i8,
    pub log2_parallel_merge_level_minus2: u8,
    pub num_tile_columns_minus1: u8,
    pub num_tile_rows_minus1: u8,
    pub column_width_minus1: [u16; 19usize],
    pub row_height_minus1: [u16; 21usize],
    pub slice_parsing_fields: _VAPictureParameterBufferHEVC__bindgen_ty_2,
    pub log2_max_pic_order_cnt_lsb_minus4: u8,
    pub num_short_term_ref_pic_sets: u8,
    pub num_long_term_ref_pic_sps: u8,
    pub num_ref_idx_l0_default_active_minus1: u8,
    pub num_ref_idx_l1_default_active_minus1: u8,
    pub pps_beta_offset_div2: i8,
    pub pps_tc_offset_div2: i8,
    pub num_extra_slice_header_bits: u8,
    pub st_rps_bits: u32,
    pub va_reserved: [u32; 8usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _VAPictureParameterBufferHEVC__bindgen_ty_1 {
    pub bits: _VAPictureParameterBufferHEVC__bindgen_ty_1__bindgen_ty_1,
    pub value: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VAPictureParameterBufferHEVC__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _VAPictureParameterBufferHEVC__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn chroma_format_idc(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_chroma_format_idc(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn separate_colour_plane_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_separate_colour_plane_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pcm_enabled_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pcm_enabled_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scaling_list_enabled_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scaling_list_enabled_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn transform_skip_enabled_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_transform_skip_enabled_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn amp_enabled_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_amp_enabled_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn strong_intra_smoothing_enabled_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_strong_intra_smoothing_enabled_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sign_data_hiding_enabled_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sign_data_hiding_enabled_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn constrained_intra_pred_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_constrained_intra_pred_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cu_qp_delta_enabled_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cu_qp_delta_enabled_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn weighted_pred_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_weighted_pred_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn weighted_bipred_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_weighted_bipred_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn transquant_bypass_enabled_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_transquant_bypass_enabled_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tiles_enabled_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tiles_enabled_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn entropy_coding_sync_enabled_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_entropy_coding_sync_enabled_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pps_loop_filter_across_slices_enabled_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pps_loop_filter_across_slices_enabled_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn loop_filter_across_tiles_enabled_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_loop_filter_across_tiles_enabled_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pcm_loop_filter_disabled_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pcm_loop_filter_disabled_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn NoPicReorderingFlag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_NoPicReorderingFlag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn NoBiPredFlag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_NoBiPredFlag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ReservedBits(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(21usize, 11u8) as u32) }
    }
    #[inline]
    pub fn set_ReservedBits(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(21usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        chroma_format_idc: u32,
        separate_colour_plane_flag: u32,
        pcm_enabled_flag: u32,
        scaling_list_enabled_flag: u32,
        transform_skip_enabled_flag: u32,
        amp_enabled_flag: u32,
        strong_intra_smoothing_enabled_flag: u32,
        sign_data_hiding_enabled_flag: u32,
        constrained_intra_pred_flag: u32,
        cu_qp_delta_enabled_flag: u32,
        weighted_pred_flag: u32,
        weighted_bipred_flag: u32,
        transquant_bypass_enabled_flag: u32,
        tiles_enabled_flag: u32,
        entropy_coding_sync_enabled_flag: u32,
        pps_loop_filter_across_slices_enabled_flag: u32,
        loop_filter_across_tiles_enabled_flag: u32,
        pcm_loop_filter_disabled_flag: u32,
        NoPicReorderingFlag: u32,
        NoBiPredFlag: u32,
        ReservedBits: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let chroma_format_idc: u32 = unsafe { ::std::mem::transmute(chroma_format_idc) };
            chroma_format_idc as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let separate_colour_plane_flag: u32 =
                unsafe { ::std::mem::transmute(separate_colour_plane_flag) };
            separate_colour_plane_flag as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let pcm_enabled_flag: u32 = unsafe { ::std::mem::transmute(pcm_enabled_flag) };
            pcm_enabled_flag as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let scaling_list_enabled_flag: u32 =
                unsafe { ::std::mem::transmute(scaling_list_enabled_flag) };
            scaling_list_enabled_flag as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let transform_skip_enabled_flag: u32 =
                unsafe { ::std::mem::transmute(transform_skip_enabled_flag) };
            transform_skip_enabled_flag as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let amp_enabled_flag: u32 = unsafe { ::std::mem::transmute(amp_enabled_flag) };
            amp_enabled_flag as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let strong_intra_smoothing_enabled_flag: u32 =
                unsafe { ::std::mem::transmute(strong_intra_smoothing_enabled_flag) };
            strong_intra_smoothing_enabled_flag as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let sign_data_hiding_enabled_flag: u32 =
                unsafe { ::std::mem::transmute(sign_data_hiding_enabled_flag) };
            sign_data_hiding_enabled_flag as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let constrained_intra_pred_flag: u32 =
                unsafe { ::std::mem::transmute(constrained_intra_pred_flag) };
            constrained_intra_pred_flag as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let cu_qp_delta_enabled_flag: u32 =
                unsafe { ::std::mem::transmute(cu_qp_delta_enabled_flag) };
            cu_qp_delta_enabled_flag as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let weighted_pred_flag: u32 = unsafe { ::std::mem::transmute(weighted_pred_flag) };
            weighted_pred_flag as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let weighted_bipred_flag: u32 = unsafe { ::std::mem::transmute(weighted_bipred_flag) };
            weighted_bipred_flag as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let transquant_bypass_enabled_flag: u32 =
                unsafe { ::std::mem::transmute(transquant_bypass_enabled_flag) };
            transquant_bypass_enabled_flag as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let tiles_enabled_flag: u32 = unsafe { ::std::mem::transmute(tiles_enabled_flag) };
            tiles_enabled_flag as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let entropy_coding_sync_enabled_flag: u32 =
                unsafe { ::std::mem::transmute(entropy_coding_sync_enabled_flag) };
            entropy_coding_sync_enabled_flag as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let pps_loop_filter_across_slices_enabled_flag: u32 =
                unsafe { ::std::mem::transmute(pps_loop_filter_across_slices_enabled_flag) };
            pps_loop_filter_across_slices_enabled_flag as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let loop_filter_across_tiles_enabled_flag: u32 =
                unsafe { ::std::mem::transmute(loop_filter_across_tiles_enabled_flag) };
            loop_filter_across_tiles_enabled_flag as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let pcm_loop_filter_disabled_flag: u32 =
                unsafe { ::std::mem::transmute(pcm_loop_filter_disabled_flag) };
            pcm_loop_filter_disabled_flag as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let NoPicReorderingFlag: u32 = unsafe { ::std::mem::transmute(NoPicReorderingFlag) };
            NoPicReorderingFlag as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let NoBiPredFlag: u32 = unsafe { ::std::mem::transmute(NoBiPredFlag) };
            NoBiPredFlag as u64
        });
        __bindgen_bitfield_unit.set(21usize, 11u8, {
            let ReservedBits: u32 = unsafe { ::std::mem::transmute(ReservedBits) };
            ReservedBits as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _VAPictureParameterBufferHEVC__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _VAPictureParameterBufferHEVC__bindgen_ty_2 {
    pub bits: _VAPictureParameterBufferHEVC__bindgen_ty_2__bindgen_ty_1,
    pub value: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VAPictureParameterBufferHEVC__bindgen_ty_2__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _VAPictureParameterBufferHEVC__bindgen_ty_2__bindgen_ty_1 {
    #[inline]
    pub fn lists_modification_present_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_lists_modification_present_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn long_term_ref_pics_present_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_long_term_ref_pics_present_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sps_temporal_mvp_enabled_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sps_temporal_mvp_enabled_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cabac_init_present_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cabac_init_present_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn output_flag_present_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_output_flag_present_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dependent_slice_segments_enabled_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dependent_slice_segments_enabled_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pps_slice_chroma_qp_offsets_present_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pps_slice_chroma_qp_offsets_present_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sample_adaptive_offset_enabled_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sample_adaptive_offset_enabled_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn deblocking_filter_override_enabled_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_deblocking_filter_override_enabled_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pps_disable_deblocking_filter_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pps_disable_deblocking_filter_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slice_segment_header_extension_present_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slice_segment_header_extension_present_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RapPicFlag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_RapPicFlag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn IdrPicFlag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_IdrPicFlag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn IntraPicFlag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_IntraPicFlag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ReservedBits(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 18u8) as u32) }
    }
    #[inline]
    pub fn set_ReservedBits(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 18u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        lists_modification_present_flag: u32,
        long_term_ref_pics_present_flag: u32,
        sps_temporal_mvp_enabled_flag: u32,
        cabac_init_present_flag: u32,
        output_flag_present_flag: u32,
        dependent_slice_segments_enabled_flag: u32,
        pps_slice_chroma_qp_offsets_present_flag: u32,
        sample_adaptive_offset_enabled_flag: u32,
        deblocking_filter_override_enabled_flag: u32,
        pps_disable_deblocking_filter_flag: u32,
        slice_segment_header_extension_present_flag: u32,
        RapPicFlag: u32,
        IdrPicFlag: u32,
        IntraPicFlag: u32,
        ReservedBits: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let lists_modification_present_flag: u32 =
                unsafe { ::std::mem::transmute(lists_modification_present_flag) };
            lists_modification_present_flag as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let long_term_ref_pics_present_flag: u32 =
                unsafe { ::std::mem::transmute(long_term_ref_pics_present_flag) };
            long_term_ref_pics_present_flag as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let sps_temporal_mvp_enabled_flag: u32 =
                unsafe { ::std::mem::transmute(sps_temporal_mvp_enabled_flag) };
            sps_temporal_mvp_enabled_flag as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let cabac_init_present_flag: u32 =
                unsafe { ::std::mem::transmute(cabac_init_present_flag) };
            cabac_init_present_flag as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let output_flag_present_flag: u32 =
                unsafe { ::std::mem::transmute(output_flag_present_flag) };
            output_flag_present_flag as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let dependent_slice_segments_enabled_flag: u32 =
                unsafe { ::std::mem::transmute(dependent_slice_segments_enabled_flag) };
            dependent_slice_segments_enabled_flag as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let pps_slice_chroma_qp_offsets_present_flag: u32 =
                unsafe { ::std::mem::transmute(pps_slice_chroma_qp_offsets_present_flag) };
            pps_slice_chroma_qp_offsets_present_flag as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let sample_adaptive_offset_enabled_flag: u32 =
                unsafe { ::std::mem::transmute(sample_adaptive_offset_enabled_flag) };
            sample_adaptive_offset_enabled_flag as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let deblocking_filter_override_enabled_flag: u32 =
                unsafe { ::std::mem::transmute(deblocking_filter_override_enabled_flag) };
            deblocking_filter_override_enabled_flag as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let pps_disable_deblocking_filter_flag: u32 =
                unsafe { ::std::mem::transmute(pps_disable_deblocking_filter_flag) };
            pps_disable_deblocking_filter_flag as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let slice_segment_header_extension_present_flag: u32 =
                unsafe { ::std::mem::transmute(slice_segment_header_extension_present_flag) };
            slice_segment_header_extension_present_flag as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let RapPicFlag: u32 = unsafe { ::std::mem::transmute(RapPicFlag) };
            RapPicFlag as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let IdrPicFlag: u32 = unsafe { ::std::mem::transmute(IdrPicFlag) };
            IdrPicFlag as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let IntraPicFlag: u32 = unsafe { ::std::mem::transmute(IntraPicFlag) };
            IntraPicFlag as u64
        });
        __bindgen_bitfield_unit.set(14usize, 18u8, {
            let ReservedBits: u32 = unsafe { ::std::mem::transmute(ReservedBits) };
            ReservedBits as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _VAPictureParameterBufferHEVC__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _VAPictureParameterBufferHEVC {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type VAPictureParameterBufferHEVC = _VAPictureParameterBufferHEVC;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _VAPictureParameterBufferHEVCRext {
    pub range_extension_pic_fields: _VAPictureParameterBufferHEVCRext__bindgen_ty_1,
    pub diff_cu_chroma_qp_offset_depth: u8,
    pub chroma_qp_offset_list_len_minus1: u8,
    pub log2_sao_offset_scale_luma: u8,
    pub log2_sao_offset_scale_chroma: u8,
    pub log2_max_transform_skip_block_size_minus2: u8,
    pub cb_qp_offset_list: [i8; 6usize],
    pub cr_qp_offset_list: [i8; 6usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _VAPictureParameterBufferHEVCRext__bindgen_ty_1 {
    pub bits: _VAPictureParameterBufferHEVCRext__bindgen_ty_1__bindgen_ty_1,
    pub value: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VAPictureParameterBufferHEVCRext__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _VAPictureParameterBufferHEVCRext__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn transform_skip_rotation_enabled_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_transform_skip_rotation_enabled_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn transform_skip_context_enabled_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_transform_skip_context_enabled_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn implicit_rdpcm_enabled_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_implicit_rdpcm_enabled_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn explicit_rdpcm_enabled_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_explicit_rdpcm_enabled_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn extended_precision_processing_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_extended_precision_processing_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn intra_smoothing_disabled_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_intra_smoothing_disabled_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn high_precision_offsets_enabled_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_high_precision_offsets_enabled_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn persistent_rice_adaptation_enabled_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_persistent_rice_adaptation_enabled_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cabac_bypass_alignment_enabled_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cabac_bypass_alignment_enabled_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cross_component_prediction_enabled_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cross_component_prediction_enabled_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn chroma_qp_offset_list_enabled_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_chroma_qp_offset_list_enabled_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 21u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 21u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        transform_skip_rotation_enabled_flag: u32,
        transform_skip_context_enabled_flag: u32,
        implicit_rdpcm_enabled_flag: u32,
        explicit_rdpcm_enabled_flag: u32,
        extended_precision_processing_flag: u32,
        intra_smoothing_disabled_flag: u32,
        high_precision_offsets_enabled_flag: u32,
        persistent_rice_adaptation_enabled_flag: u32,
        cabac_bypass_alignment_enabled_flag: u32,
        cross_component_prediction_enabled_flag: u32,
        chroma_qp_offset_list_enabled_flag: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let transform_skip_rotation_enabled_flag: u32 =
                unsafe { ::std::mem::transmute(transform_skip_rotation_enabled_flag) };
            transform_skip_rotation_enabled_flag as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let transform_skip_context_enabled_flag: u32 =
                unsafe { ::std::mem::transmute(transform_skip_context_enabled_flag) };
            transform_skip_context_enabled_flag as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let implicit_rdpcm_enabled_flag: u32 =
                unsafe { ::std::mem::transmute(implicit_rdpcm_enabled_flag) };
            implicit_rdpcm_enabled_flag as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let explicit_rdpcm_enabled_flag: u32 =
                unsafe { ::std::mem::transmute(explicit_rdpcm_enabled_flag) };
            explicit_rdpcm_enabled_flag as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let extended_precision_processing_flag: u32 =
                unsafe { ::std::mem::transmute(extended_precision_processing_flag) };
            extended_precision_processing_flag as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let intra_smoothing_disabled_flag: u32 =
                unsafe { ::std::mem::transmute(intra_smoothing_disabled_flag) };
            intra_smoothing_disabled_flag as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let high_precision_offsets_enabled_flag: u32 =
                unsafe { ::std::mem::transmute(high_precision_offsets_enabled_flag) };
            high_precision_offsets_enabled_flag as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let persistent_rice_adaptation_enabled_flag: u32 =
                unsafe { ::std::mem::transmute(persistent_rice_adaptation_enabled_flag) };
            persistent_rice_adaptation_enabled_flag as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let cabac_bypass_alignment_enabled_flag: u32 =
                unsafe { ::std::mem::transmute(cabac_bypass_alignment_enabled_flag) };
            cabac_bypass_alignment_enabled_flag as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let cross_component_prediction_enabled_flag: u32 =
                unsafe { ::std::mem::transmute(cross_component_prediction_enabled_flag) };
            cross_component_prediction_enabled_flag as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let chroma_qp_offset_list_enabled_flag: u32 =
                unsafe { ::std::mem::transmute(chroma_qp_offset_list_enabled_flag) };
            chroma_qp_offset_list_enabled_flag as u64
        });
        __bindgen_bitfield_unit.set(11usize, 21u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _VAPictureParameterBufferHEVCRext__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _VAPictureParameterBufferHEVCRext {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type VAPictureParameterBufferHEVCRext = _VAPictureParameterBufferHEVCRext;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _VAPictureParameterBufferHEVCScc {
    pub screen_content_pic_fields: _VAPictureParameterBufferHEVCScc__bindgen_ty_1,
    pub palette_max_size: u8,
    pub delta_palette_max_predictor_size: u8,
    pub predictor_palette_size: u8,
    pub predictor_palette_entries: [[u16; 128usize]; 3usize],
    pub pps_act_y_qp_offset_plus5: i8,
    pub pps_act_cb_qp_offset_plus5: i8,
    pub pps_act_cr_qp_offset_plus3: i8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _VAPictureParameterBufferHEVCScc__bindgen_ty_1 {
    pub bits: _VAPictureParameterBufferHEVCScc__bindgen_ty_1__bindgen_ty_1,
    pub value: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VAPictureParameterBufferHEVCScc__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _VAPictureParameterBufferHEVCScc__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn pps_curr_pic_ref_enabled_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pps_curr_pic_ref_enabled_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn palette_mode_enabled_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_palette_mode_enabled_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn motion_vector_resolution_control_idc(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_motion_vector_resolution_control_idc(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn intra_boundary_filtering_disabled_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_intra_boundary_filtering_disabled_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn residual_adaptive_colour_transform_enabled_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_residual_adaptive_colour_transform_enabled_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pps_slice_act_qp_offsets_present_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pps_slice_act_qp_offsets_present_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 25u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 25u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        pps_curr_pic_ref_enabled_flag: u32,
        palette_mode_enabled_flag: u32,
        motion_vector_resolution_control_idc: u32,
        intra_boundary_filtering_disabled_flag: u32,
        residual_adaptive_colour_transform_enabled_flag: u32,
        pps_slice_act_qp_offsets_present_flag: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let pps_curr_pic_ref_enabled_flag: u32 =
                unsafe { ::std::mem::transmute(pps_curr_pic_ref_enabled_flag) };
            pps_curr_pic_ref_enabled_flag as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let palette_mode_enabled_flag: u32 =
                unsafe { ::std::mem::transmute(palette_mode_enabled_flag) };
            palette_mode_enabled_flag as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let motion_vector_resolution_control_idc: u32 =
                unsafe { ::std::mem::transmute(motion_vector_resolution_control_idc) };
            motion_vector_resolution_control_idc as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let intra_boundary_filtering_disabled_flag: u32 =
                unsafe { ::std::mem::transmute(intra_boundary_filtering_disabled_flag) };
            intra_boundary_filtering_disabled_flag as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let residual_adaptive_colour_transform_enabled_flag: u32 =
                unsafe { ::std::mem::transmute(residual_adaptive_colour_transform_enabled_flag) };
            residual_adaptive_colour_transform_enabled_flag as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let pps_slice_act_qp_offsets_present_flag: u32 =
                unsafe { ::std::mem::transmute(pps_slice_act_qp_offsets_present_flag) };
            pps_slice_act_qp_offsets_present_flag as u64
        });
        __bindgen_bitfield_unit.set(7usize, 25u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _VAPictureParameterBufferHEVCScc__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _VAPictureParameterBufferHEVCScc {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type VAPictureParameterBufferHEVCScc = _VAPictureParameterBufferHEVCScc;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _VAPictureParameterBufferHEVCExtension {
    pub base: VAPictureParameterBufferHEVC,
    pub rext: VAPictureParameterBufferHEVCRext,
    pub scc: VAPictureParameterBufferHEVCScc,
}
impl Default for _VAPictureParameterBufferHEVCExtension {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type VAPictureParameterBufferHEVCExtension = _VAPictureParameterBufferHEVCExtension;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _VASliceParameterBufferHEVC {
    pub slice_data_size: u32,
    pub slice_data_offset: u32,
    pub slice_data_flag: u32,
    pub slice_data_byte_offset: u32,
    pub slice_segment_address: u32,
    pub RefPicList: [[u8; 15usize]; 2usize],
    pub LongSliceFlags: _VASliceParameterBufferHEVC__bindgen_ty_1,
    pub collocated_ref_idx: u8,
    pub num_ref_idx_l0_active_minus1: u8,
    pub num_ref_idx_l1_active_minus1: u8,
    pub slice_qp_delta: i8,
    pub slice_cb_qp_offset: i8,
    pub slice_cr_qp_offset: i8,
    pub slice_beta_offset_div2: i8,
    pub slice_tc_offset_div2: i8,
    pub luma_log2_weight_denom: u8,
    pub delta_chroma_log2_weight_denom: i8,
    pub delta_luma_weight_l0: [i8; 15usize],
    pub luma_offset_l0: [i8; 15usize],
    pub delta_chroma_weight_l0: [[i8; 2usize]; 15usize],
    pub ChromaOffsetL0: [[i8; 2usize]; 15usize],
    pub delta_luma_weight_l1: [i8; 15usize],
    pub luma_offset_l1: [i8; 15usize],
    pub delta_chroma_weight_l1: [[i8; 2usize]; 15usize],
    pub ChromaOffsetL1: [[i8; 2usize]; 15usize],
    pub five_minus_max_num_merge_cand: u8,
    pub num_entry_point_offsets: u16,
    pub entry_offset_to_subset_array: u16,
    pub slice_data_num_emu_prevn_bytes: u16,
    pub va_reserved: [u32; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _VASliceParameterBufferHEVC__bindgen_ty_1 {
    pub value: u32,
    pub fields: _VASliceParameterBufferHEVC__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VASliceParameterBufferHEVC__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _VASliceParameterBufferHEVC__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn LastSliceOfPic(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_LastSliceOfPic(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dependent_slice_segment_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dependent_slice_segment_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slice_type(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_slice_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn color_plane_id(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_color_plane_id(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn slice_sao_luma_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slice_sao_luma_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slice_sao_chroma_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slice_sao_chroma_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mvd_l1_zero_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mvd_l1_zero_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cabac_init_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cabac_init_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slice_temporal_mvp_enabled_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slice_temporal_mvp_enabled_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slice_deblocking_filter_disabled_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slice_deblocking_filter_disabled_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn collocated_from_l0_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_collocated_from_l0_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slice_loop_filter_across_slices_enabled_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slice_loop_filter_across_slices_enabled_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 18u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 18u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        LastSliceOfPic: u32,
        dependent_slice_segment_flag: u32,
        slice_type: u32,
        color_plane_id: u32,
        slice_sao_luma_flag: u32,
        slice_sao_chroma_flag: u32,
        mvd_l1_zero_flag: u32,
        cabac_init_flag: u32,
        slice_temporal_mvp_enabled_flag: u32,
        slice_deblocking_filter_disabled_flag: u32,
        collocated_from_l0_flag: u32,
        slice_loop_filter_across_slices_enabled_flag: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let LastSliceOfPic: u32 = unsafe { ::std::mem::transmute(LastSliceOfPic) };
            LastSliceOfPic as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let dependent_slice_segment_flag: u32 =
                unsafe { ::std::mem::transmute(dependent_slice_segment_flag) };
            dependent_slice_segment_flag as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let slice_type: u32 = unsafe { ::std::mem::transmute(slice_type) };
            slice_type as u64
        });
        __bindgen_bitfield_unit.set(4usize, 2u8, {
            let color_plane_id: u32 = unsafe { ::std::mem::transmute(color_plane_id) };
            color_plane_id as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let slice_sao_luma_flag: u32 = unsafe { ::std::mem::transmute(slice_sao_luma_flag) };
            slice_sao_luma_flag as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let slice_sao_chroma_flag: u32 =
                unsafe { ::std::mem::transmute(slice_sao_chroma_flag) };
            slice_sao_chroma_flag as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let mvd_l1_zero_flag: u32 = unsafe { ::std::mem::transmute(mvd_l1_zero_flag) };
            mvd_l1_zero_flag as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let cabac_init_flag: u32 = unsafe { ::std::mem::transmute(cabac_init_flag) };
            cabac_init_flag as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let slice_temporal_mvp_enabled_flag: u32 =
                unsafe { ::std::mem::transmute(slice_temporal_mvp_enabled_flag) };
            slice_temporal_mvp_enabled_flag as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let slice_deblocking_filter_disabled_flag: u32 =
                unsafe { ::std::mem::transmute(slice_deblocking_filter_disabled_flag) };
            slice_deblocking_filter_disabled_flag as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let collocated_from_l0_flag: u32 =
                unsafe { ::std::mem::transmute(collocated_from_l0_flag) };
            collocated_from_l0_flag as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let slice_loop_filter_across_slices_enabled_flag: u32 =
                unsafe { ::std::mem::transmute(slice_loop_filter_across_slices_enabled_flag) };
            slice_loop_filter_across_slices_enabled_flag as u64
        });
        __bindgen_bitfield_unit.set(14usize, 18u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _VASliceParameterBufferHEVC__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _VASliceParameterBufferHEVC {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type VASliceParameterBufferHEVC = _VASliceParameterBufferHEVC;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _VASliceParameterBufferHEVCRext {
    pub luma_offset_l0: [i16; 15usize],
    pub ChromaOffsetL0: [[i16; 2usize]; 15usize],
    pub luma_offset_l1: [i16; 15usize],
    pub ChromaOffsetL1: [[i16; 2usize]; 15usize],
    pub slice_ext_flags: _VASliceParameterBufferHEVCRext__bindgen_ty_1,
    pub slice_act_y_qp_offset: i8,
    pub slice_act_cb_qp_offset: i8,
    pub slice_act_cr_qp_offset: i8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _VASliceParameterBufferHEVCRext__bindgen_ty_1 {
    pub bits: _VASliceParameterBufferHEVCRext__bindgen_ty_1__bindgen_ty_1,
    pub value: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VASliceParameterBufferHEVCRext__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _VASliceParameterBufferHEVCRext__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn cu_chroma_qp_offset_enabled_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cu_chroma_qp_offset_enabled_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn use_integer_mv_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_use_integer_mv_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        cu_chroma_qp_offset_enabled_flag: u32,
        use_integer_mv_flag: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let cu_chroma_qp_offset_enabled_flag: u32 =
                unsafe { ::std::mem::transmute(cu_chroma_qp_offset_enabled_flag) };
            cu_chroma_qp_offset_enabled_flag as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let use_integer_mv_flag: u32 = unsafe { ::std::mem::transmute(use_integer_mv_flag) };
            use_integer_mv_flag as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _VASliceParameterBufferHEVCRext__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _VASliceParameterBufferHEVCRext {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type VASliceParameterBufferHEVCRext = _VASliceParameterBufferHEVCRext;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _VASliceParameterBufferHEVCExtension {
    pub base: VASliceParameterBufferHEVC,
    pub rext: VASliceParameterBufferHEVCRext,
}
impl Default for _VASliceParameterBufferHEVCExtension {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type VASliceParameterBufferHEVCExtension = _VASliceParameterBufferHEVCExtension;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _VAIQMatrixBufferHEVC {
    pub ScalingList4x4: [[u8; 16usize]; 6usize],
    pub ScalingList8x8: [[u8; 64usize]; 6usize],
    pub ScalingList16x16: [[u8; 64usize]; 6usize],
    pub ScalingList32x32: [[u8; 64usize]; 2usize],
    pub ScalingListDC16x16: [u8; 6usize],
    pub ScalingListDC32x32: [u8; 2usize],
    pub va_reserved: [u32; 4usize],
}
impl Default for _VAIQMatrixBufferHEVC {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type VAIQMatrixBufferHEVC = _VAIQMatrixBufferHEVC;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VABoolCoderContextVPX {
    pub range: u8,
    pub value: u8,
    pub count: u8,
}
pub type VABoolCoderContextVPX = _VABoolCoderContextVPX;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _VAPictureParameterBufferVP8 {
    pub frame_width: u32,
    pub frame_height: u32,
    pub last_ref_frame: VASurfaceID,
    pub golden_ref_frame: VASurfaceID,
    pub alt_ref_frame: VASurfaceID,
    pub out_of_loop_frame: VASurfaceID,
    pub pic_fields: _VAPictureParameterBufferVP8__bindgen_ty_1,
    pub mb_segment_tree_probs: [u8; 3usize],
    pub loop_filter_level: [u8; 4usize],
    pub loop_filter_deltas_ref_frame: [i8; 4usize],
    pub loop_filter_deltas_mode: [i8; 4usize],
    pub prob_skip_false: u8,
    pub prob_intra: u8,
    pub prob_last: u8,
    pub prob_gf: u8,
    pub y_mode_probs: [u8; 4usize],
    pub uv_mode_probs: [u8; 3usize],
    pub mv_probs: [[u8; 19usize]; 2usize],
    pub bool_coder_ctx: VABoolCoderContextVPX,
    pub va_reserved: [u32; 4usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _VAPictureParameterBufferVP8__bindgen_ty_1 {
    pub bits: _VAPictureParameterBufferVP8__bindgen_ty_1__bindgen_ty_1,
    pub value: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VAPictureParameterBufferVP8__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize]>,
    pub __bindgen_padding_0: u8,
}
impl _VAPictureParameterBufferVP8__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn key_frame(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_key_frame(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn version(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_version(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn segmentation_enabled(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_segmentation_enabled(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn update_mb_segmentation_map(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_update_mb_segmentation_map(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn update_segment_feature_data(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_update_segment_feature_data(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn filter_type(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_filter_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sharpness_level(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_sharpness_level(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn loop_filter_adj_enable(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_loop_filter_adj_enable(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mode_ref_lf_delta_update(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mode_ref_lf_delta_update(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sign_bias_golden(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sign_bias_golden(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sign_bias_alternate(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sign_bias_alternate(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mb_no_coeff_skip(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mb_no_coeff_skip(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn loop_filter_disable(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_loop_filter_disable(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        key_frame: u32,
        version: u32,
        segmentation_enabled: u32,
        update_mb_segmentation_map: u32,
        update_segment_feature_data: u32,
        filter_type: u32,
        sharpness_level: u32,
        loop_filter_adj_enable: u32,
        mode_ref_lf_delta_update: u32,
        sign_bias_golden: u32,
        sign_bias_alternate: u32,
        mb_no_coeff_skip: u32,
        loop_filter_disable: u32,
    ) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let key_frame: u32 = unsafe { ::std::mem::transmute(key_frame) };
            key_frame as u64
        });
        __bindgen_bitfield_unit.set(1usize, 3u8, {
            let version: u32 = unsafe { ::std::mem::transmute(version) };
            version as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let segmentation_enabled: u32 = unsafe { ::std::mem::transmute(segmentation_enabled) };
            segmentation_enabled as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let update_mb_segmentation_map: u32 =
                unsafe { ::std::mem::transmute(update_mb_segmentation_map) };
            update_mb_segmentation_map as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let update_segment_feature_data: u32 =
                unsafe { ::std::mem::transmute(update_segment_feature_data) };
            update_segment_feature_data as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let filter_type: u32 = unsafe { ::std::mem::transmute(filter_type) };
            filter_type as u64
        });
        __bindgen_bitfield_unit.set(8usize, 3u8, {
            let sharpness_level: u32 = unsafe { ::std::mem::transmute(sharpness_level) };
            sharpness_level as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let loop_filter_adj_enable: u32 =
                unsafe { ::std::mem::transmute(loop_filter_adj_enable) };
            loop_filter_adj_enable as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let mode_ref_lf_delta_update: u32 =
                unsafe { ::std::mem::transmute(mode_ref_lf_delta_update) };
            mode_ref_lf_delta_update as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let sign_bias_golden: u32 = unsafe { ::std::mem::transmute(sign_bias_golden) };
            sign_bias_golden as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let sign_bias_alternate: u32 = unsafe { ::std::mem::transmute(sign_bias_alternate) };
            sign_bias_alternate as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let mb_no_coeff_skip: u32 = unsafe { ::std::mem::transmute(mb_no_coeff_skip) };
            mb_no_coeff_skip as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let loop_filter_disable: u32 = unsafe { ::std::mem::transmute(loop_filter_disable) };
            loop_filter_disable as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _VAPictureParameterBufferVP8__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _VAPictureParameterBufferVP8 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type VAPictureParameterBufferVP8 = _VAPictureParameterBufferVP8;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VASliceParameterBufferVP8 {
    pub slice_data_size: u32,
    pub slice_data_offset: u32,
    pub slice_data_flag: u32,
    pub macroblock_offset: u32,
    pub num_of_partitions: u8,
    pub partition_size: [u32; 9usize],
    pub va_reserved: [u32; 4usize],
}
pub type VASliceParameterBufferVP8 = _VASliceParameterBufferVP8;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VAProbabilityDataBufferVP8 {
    pub dct_coeff_probs: [[[[u8; 11usize]; 3usize]; 8usize]; 4usize],
    pub va_reserved: [u32; 4usize],
}
pub type VAProbabilityDataBufferVP8 = _VAProbabilityDataBufferVP8;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VAIQMatrixBufferVP8 {
    pub quantization_index: [[u16; 6usize]; 4usize],
    pub va_reserved: [u32; 4usize],
}
pub type VAIQMatrixBufferVP8 = _VAIQMatrixBufferVP8;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _VADecPictureParameterBufferVP9 {
    pub frame_width: u16,
    pub frame_height: u16,
    pub reference_frames: [VASurfaceID; 8usize],
    pub pic_fields: _VADecPictureParameterBufferVP9__bindgen_ty_1,
    pub filter_level: u8,
    pub sharpness_level: u8,
    pub log2_tile_rows: u8,
    pub log2_tile_columns: u8,
    pub frame_header_length_in_bytes: u8,
    pub first_partition_size: u16,
    pub mb_segment_tree_probs: [u8; 7usize],
    pub segment_pred_probs: [u8; 3usize],
    pub profile: u8,
    pub bit_depth: u8,
    pub va_reserved: [u32; 8usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _VADecPictureParameterBufferVP9__bindgen_ty_1 {
    pub bits: _VADecPictureParameterBufferVP9__bindgen_ty_1__bindgen_ty_1,
    pub value: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VADecPictureParameterBufferVP9__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _VADecPictureParameterBufferVP9__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn subsampling_x(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_subsampling_x(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn subsampling_y(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_subsampling_y(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn frame_type(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_frame_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn show_frame(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_show_frame(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn error_resilient_mode(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_error_resilient_mode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn intra_only(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_intra_only(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn allow_high_precision_mv(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_allow_high_precision_mv(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mcomp_filter_type(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_mcomp_filter_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn frame_parallel_decoding_mode(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_frame_parallel_decoding_mode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reset_frame_context(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_reset_frame_context(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn refresh_frame_context(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_refresh_frame_context(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn frame_context_idx(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_frame_context_idx(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn segmentation_enabled(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_segmentation_enabled(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn segmentation_temporal_update(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_segmentation_temporal_update(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn segmentation_update_map(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_segmentation_update_map(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn last_ref_frame(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_last_ref_frame(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn last_ref_frame_sign_bias(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_last_ref_frame_sign_bias(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn golden_ref_frame(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(23usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_golden_ref_frame(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(23usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn golden_ref_frame_sign_bias(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_golden_ref_frame_sign_bias(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn alt_ref_frame(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(27usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_alt_ref_frame(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(27usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn alt_ref_frame_sign_bias(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_alt_ref_frame_sign_bias(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn lossless_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_lossless_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        subsampling_x: u32,
        subsampling_y: u32,
        frame_type: u32,
        show_frame: u32,
        error_resilient_mode: u32,
        intra_only: u32,
        allow_high_precision_mv: u32,
        mcomp_filter_type: u32,
        frame_parallel_decoding_mode: u32,
        reset_frame_context: u32,
        refresh_frame_context: u32,
        frame_context_idx: u32,
        segmentation_enabled: u32,
        segmentation_temporal_update: u32,
        segmentation_update_map: u32,
        last_ref_frame: u32,
        last_ref_frame_sign_bias: u32,
        golden_ref_frame: u32,
        golden_ref_frame_sign_bias: u32,
        alt_ref_frame: u32,
        alt_ref_frame_sign_bias: u32,
        lossless_flag: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let subsampling_x: u32 = unsafe { ::std::mem::transmute(subsampling_x) };
            subsampling_x as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let subsampling_y: u32 = unsafe { ::std::mem::transmute(subsampling_y) };
            subsampling_y as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let frame_type: u32 = unsafe { ::std::mem::transmute(frame_type) };
            frame_type as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let show_frame: u32 = unsafe { ::std::mem::transmute(show_frame) };
            show_frame as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let error_resilient_mode: u32 = unsafe { ::std::mem::transmute(error_resilient_mode) };
            error_resilient_mode as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let intra_only: u32 = unsafe { ::std::mem::transmute(intra_only) };
            intra_only as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let allow_high_precision_mv: u32 =
                unsafe { ::std::mem::transmute(allow_high_precision_mv) };
            allow_high_precision_mv as u64
        });
        __bindgen_bitfield_unit.set(7usize, 3u8, {
            let mcomp_filter_type: u32 = unsafe { ::std::mem::transmute(mcomp_filter_type) };
            mcomp_filter_type as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let frame_parallel_decoding_mode: u32 =
                unsafe { ::std::mem::transmute(frame_parallel_decoding_mode) };
            frame_parallel_decoding_mode as u64
        });
        __bindgen_bitfield_unit.set(11usize, 2u8, {
            let reset_frame_context: u32 = unsafe { ::std::mem::transmute(reset_frame_context) };
            reset_frame_context as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let refresh_frame_context: u32 =
                unsafe { ::std::mem::transmute(refresh_frame_context) };
            refresh_frame_context as u64
        });
        __bindgen_bitfield_unit.set(14usize, 2u8, {
            let frame_context_idx: u32 = unsafe { ::std::mem::transmute(frame_context_idx) };
            frame_context_idx as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let segmentation_enabled: u32 = unsafe { ::std::mem::transmute(segmentation_enabled) };
            segmentation_enabled as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let segmentation_temporal_update: u32 =
                unsafe { ::std::mem::transmute(segmentation_temporal_update) };
            segmentation_temporal_update as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let segmentation_update_map: u32 =
                unsafe { ::std::mem::transmute(segmentation_update_map) };
            segmentation_update_map as u64
        });
        __bindgen_bitfield_unit.set(19usize, 3u8, {
            let last_ref_frame: u32 = unsafe { ::std::mem::transmute(last_ref_frame) };
            last_ref_frame as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let last_ref_frame_sign_bias: u32 =
                unsafe { ::std::mem::transmute(last_ref_frame_sign_bias) };
            last_ref_frame_sign_bias as u64
        });
        __bindgen_bitfield_unit.set(23usize, 3u8, {
            let golden_ref_frame: u32 = unsafe { ::std::mem::transmute(golden_ref_frame) };
            golden_ref_frame as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let golden_ref_frame_sign_bias: u32 =
                unsafe { ::std::mem::transmute(golden_ref_frame_sign_bias) };
            golden_ref_frame_sign_bias as u64
        });
        __bindgen_bitfield_unit.set(27usize, 3u8, {
            let alt_ref_frame: u32 = unsafe { ::std::mem::transmute(alt_ref_frame) };
            alt_ref_frame as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let alt_ref_frame_sign_bias: u32 =
                unsafe { ::std::mem::transmute(alt_ref_frame_sign_bias) };
            alt_ref_frame_sign_bias as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let lossless_flag: u32 = unsafe { ::std::mem::transmute(lossless_flag) };
            lossless_flag as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _VADecPictureParameterBufferVP9__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _VADecPictureParameterBufferVP9 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type VADecPictureParameterBufferVP9 = _VADecPictureParameterBufferVP9;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _VASegmentParameterVP9 {
    pub segment_flags: _VASegmentParameterVP9__bindgen_ty_1,
    pub filter_level: [[u8; 2usize]; 4usize],
    pub luma_ac_quant_scale: i16,
    pub luma_dc_quant_scale: i16,
    pub chroma_ac_quant_scale: i16,
    pub chroma_dc_quant_scale: i16,
    pub va_reserved: [u32; 4usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _VASegmentParameterVP9__bindgen_ty_1 {
    pub fields: _VASegmentParameterVP9__bindgen_ty_1__bindgen_ty_1,
    pub value: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VASegmentParameterVP9__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: u8,
}
impl _VASegmentParameterVP9__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn segment_reference_enabled(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_segment_reference_enabled(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn segment_reference(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_segment_reference(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn segment_reference_skipped(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_segment_reference_skipped(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        segment_reference_enabled: u16,
        segment_reference: u16,
        segment_reference_skipped: u16,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let segment_reference_enabled: u16 =
                unsafe { ::std::mem::transmute(segment_reference_enabled) };
            segment_reference_enabled as u64
        });
        __bindgen_bitfield_unit.set(1usize, 2u8, {
            let segment_reference: u16 = unsafe { ::std::mem::transmute(segment_reference) };
            segment_reference as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let segment_reference_skipped: u16 =
                unsafe { ::std::mem::transmute(segment_reference_skipped) };
            segment_reference_skipped as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _VASegmentParameterVP9__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _VASegmentParameterVP9 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type VASegmentParameterVP9 = _VASegmentParameterVP9;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _VASliceParameterBufferVP9 {
    pub slice_data_size: u32,
    pub slice_data_offset: u32,
    pub slice_data_flag: u32,
    pub seg_param: [VASegmentParameterVP9; 8usize],
    pub va_reserved: [u32; 4usize],
}
impl Default for _VASliceParameterBufferVP9 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type VASliceParameterBufferVP9 = _VASliceParameterBufferVP9;
#[repr(C)]
#[derive(Copy, Clone)]
pub union VAConfigAttribValDecAV1Features {
    pub bits: VAConfigAttribValDecAV1Features__bindgen_ty_1,
    pub value: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct VAConfigAttribValDecAV1Features__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl VAConfigAttribValDecAV1Features__bindgen_ty_1 {
    #[inline]
    pub fn lst_support(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_lst_support(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(lst_support: u32, reserved: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let lst_support: u32 = unsafe { ::std::mem::transmute(lst_support) };
            lst_support as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for VAConfigAttribValDecAV1Features {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _VASegmentationStructAV1 {
    pub segment_info_fields: _VASegmentationStructAV1__bindgen_ty_1,
    pub feature_data: [[i16; 8usize]; 8usize],
    pub feature_mask: [u8; 8usize],
    pub va_reserved: [u32; 4usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _VASegmentationStructAV1__bindgen_ty_1 {
    pub bits: _VASegmentationStructAV1__bindgen_ty_1__bindgen_ty_1,
    pub value: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VASegmentationStructAV1__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _VASegmentationStructAV1__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn enabled(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enabled(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn update_map(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_update_map(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn temporal_update(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_temporal_update(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn update_data(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_update_data(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 28u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 28u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        enabled: u32,
        update_map: u32,
        temporal_update: u32,
        update_data: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let enabled: u32 = unsafe { ::std::mem::transmute(enabled) };
            enabled as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let update_map: u32 = unsafe { ::std::mem::transmute(update_map) };
            update_map as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let temporal_update: u32 = unsafe { ::std::mem::transmute(temporal_update) };
            temporal_update as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let update_data: u32 = unsafe { ::std::mem::transmute(update_data) };
            update_data as u64
        });
        __bindgen_bitfield_unit.set(4usize, 28u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _VASegmentationStructAV1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _VASegmentationStructAV1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type VASegmentationStructAV1 = _VASegmentationStructAV1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _VAFilmGrainStructAV1 {
    pub film_grain_info_fields: _VAFilmGrainStructAV1__bindgen_ty_1,
    pub grain_seed: u16,
    pub num_y_points: u8,
    pub point_y_value: [u8; 14usize],
    pub point_y_scaling: [u8; 14usize],
    pub num_cb_points: u8,
    pub point_cb_value: [u8; 10usize],
    pub point_cb_scaling: [u8; 10usize],
    pub num_cr_points: u8,
    pub point_cr_value: [u8; 10usize],
    pub point_cr_scaling: [u8; 10usize],
    pub ar_coeffs_y: [i8; 24usize],
    pub ar_coeffs_cb: [i8; 25usize],
    pub ar_coeffs_cr: [i8; 25usize],
    pub cb_mult: u8,
    pub cb_luma_mult: u8,
    pub cb_offset: u16,
    pub cr_mult: u8,
    pub cr_luma_mult: u8,
    pub cr_offset: u16,
    pub va_reserved: [u32; 4usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _VAFilmGrainStructAV1__bindgen_ty_1 {
    pub bits: _VAFilmGrainStructAV1__bindgen_ty_1__bindgen_ty_1,
    pub value: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VAFilmGrainStructAV1__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _VAFilmGrainStructAV1__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn apply_grain(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_apply_grain(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn chroma_scaling_from_luma(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_chroma_scaling_from_luma(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn grain_scaling_minus_8(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_grain_scaling_minus_8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn ar_coeff_lag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_ar_coeff_lag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn ar_coeff_shift_minus_6(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_ar_coeff_shift_minus_6(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn grain_scale_shift(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_grain_scale_shift(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn overlap_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_overlap_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn clip_to_restricted_range(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_clip_to_restricted_range(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        apply_grain: u32,
        chroma_scaling_from_luma: u32,
        grain_scaling_minus_8: u32,
        ar_coeff_lag: u32,
        ar_coeff_shift_minus_6: u32,
        grain_scale_shift: u32,
        overlap_flag: u32,
        clip_to_restricted_range: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let apply_grain: u32 = unsafe { ::std::mem::transmute(apply_grain) };
            apply_grain as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let chroma_scaling_from_luma: u32 =
                unsafe { ::std::mem::transmute(chroma_scaling_from_luma) };
            chroma_scaling_from_luma as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let grain_scaling_minus_8: u32 =
                unsafe { ::std::mem::transmute(grain_scaling_minus_8) };
            grain_scaling_minus_8 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 2u8, {
            let ar_coeff_lag: u32 = unsafe { ::std::mem::transmute(ar_coeff_lag) };
            ar_coeff_lag as u64
        });
        __bindgen_bitfield_unit.set(6usize, 2u8, {
            let ar_coeff_shift_minus_6: u32 =
                unsafe { ::std::mem::transmute(ar_coeff_shift_minus_6) };
            ar_coeff_shift_minus_6 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 2u8, {
            let grain_scale_shift: u32 = unsafe { ::std::mem::transmute(grain_scale_shift) };
            grain_scale_shift as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let overlap_flag: u32 = unsafe { ::std::mem::transmute(overlap_flag) };
            overlap_flag as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let clip_to_restricted_range: u32 =
                unsafe { ::std::mem::transmute(clip_to_restricted_range) };
            clip_to_restricted_range as u64
        });
        __bindgen_bitfield_unit.set(12usize, 20u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _VAFilmGrainStructAV1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _VAFilmGrainStructAV1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type VAFilmGrainStructAV1 = _VAFilmGrainStructAV1;
pub mod VAAV1TransformationType {
    pub type Type = ::std::os::raw::c_uint;
    pub const VAAV1TransformationIdentity: Type = 0;
    pub const VAAV1TransformationTranslation: Type = 1;
    pub const VAAV1TransformationRotzoom: Type = 2;
    pub const VAAV1TransformationAffine: Type = 3;
    pub const VAAV1TransformationCount: Type = 4;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _VAWarpedMotionParamsAV1 {
    pub wmtype: VAAV1TransformationType::Type,
    pub wmmat: [i32; 8usize],
    pub invalid: u8,
    pub va_reserved: [u32; 4usize],
}
impl Default for _VAWarpedMotionParamsAV1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type VAWarpedMotionParamsAV1 = _VAWarpedMotionParamsAV1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _VADecPictureParameterBufferAV1 {
    pub profile: u8,
    pub order_hint_bits_minus_1: u8,
    pub bit_depth_idx: u8,
    pub matrix_coefficients: u8,
    pub seq_info_fields: _VADecPictureParameterBufferAV1__bindgen_ty_1,
    pub current_frame: VASurfaceID,
    pub current_display_picture: VASurfaceID,
    pub anchor_frames_num: u8,
    pub anchor_frames_list: *mut VASurfaceID,
    pub frame_width_minus1: u16,
    pub frame_height_minus1: u16,
    pub output_frame_width_in_tiles_minus_1: u16,
    pub output_frame_height_in_tiles_minus_1: u16,
    pub ref_frame_map: [VASurfaceID; 8usize],
    pub ref_frame_idx: [u8; 7usize],
    pub primary_ref_frame: u8,
    pub order_hint: u8,
    pub seg_info: VASegmentationStructAV1,
    pub film_grain_info: VAFilmGrainStructAV1,
    pub tile_cols: u8,
    pub tile_rows: u8,
    pub width_in_sbs_minus_1: [u16; 63usize],
    pub height_in_sbs_minus_1: [u16; 63usize],
    pub tile_count_minus_1: u16,
    pub context_update_tile_id: u16,
    pub pic_info_fields: _VADecPictureParameterBufferAV1__bindgen_ty_2,
    pub superres_scale_denominator: u8,
    pub interp_filter: u8,
    pub filter_level: [u8; 2usize],
    pub filter_level_u: u8,
    pub filter_level_v: u8,
    pub loop_filter_info_fields: _VADecPictureParameterBufferAV1__bindgen_ty_3,
    pub ref_deltas: [i8; 8usize],
    pub mode_deltas: [i8; 2usize],
    pub base_qindex: u8,
    pub y_dc_delta_q: i8,
    pub u_dc_delta_q: i8,
    pub u_ac_delta_q: i8,
    pub v_dc_delta_q: i8,
    pub v_ac_delta_q: i8,
    pub qmatrix_fields: _VADecPictureParameterBufferAV1__bindgen_ty_4,
    pub mode_control_fields: _VADecPictureParameterBufferAV1__bindgen_ty_5,
    pub cdef_damping_minus_3: u8,
    pub cdef_bits: u8,
    pub cdef_y_strengths: [u8; 8usize],
    pub cdef_uv_strengths: [u8; 8usize],
    pub loop_restoration_fields: _VADecPictureParameterBufferAV1__bindgen_ty_6,
    pub wm: [VAWarpedMotionParamsAV1; 7usize],
    pub va_reserved: [u32; 8usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _VADecPictureParameterBufferAV1__bindgen_ty_1 {
    pub fields: _VADecPictureParameterBufferAV1__bindgen_ty_1__bindgen_ty_1,
    pub value: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VADecPictureParameterBufferAV1__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _VADecPictureParameterBufferAV1__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn still_picture(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_still_picture(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn use_128x128_superblock(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_use_128x128_superblock(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enable_filter_intra(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enable_filter_intra(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enable_intra_edge_filter(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enable_intra_edge_filter(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enable_interintra_compound(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enable_interintra_compound(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enable_masked_compound(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enable_masked_compound(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enable_dual_filter(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enable_dual_filter(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enable_order_hint(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enable_order_hint(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enable_jnt_comp(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enable_jnt_comp(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enable_cdef(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enable_cdef(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mono_chrome(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mono_chrome(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn color_range(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_color_range(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn subsampling_x(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_subsampling_x(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn subsampling_y(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_subsampling_y(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn chroma_sample_position(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_chroma_sample_position(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn film_grain_params_present(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_film_grain_params_present(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        still_picture: u32,
        use_128x128_superblock: u32,
        enable_filter_intra: u32,
        enable_intra_edge_filter: u32,
        enable_interintra_compound: u32,
        enable_masked_compound: u32,
        enable_dual_filter: u32,
        enable_order_hint: u32,
        enable_jnt_comp: u32,
        enable_cdef: u32,
        mono_chrome: u32,
        color_range: u32,
        subsampling_x: u32,
        subsampling_y: u32,
        chroma_sample_position: u32,
        film_grain_params_present: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let still_picture: u32 = unsafe { ::std::mem::transmute(still_picture) };
            still_picture as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let use_128x128_superblock: u32 =
                unsafe { ::std::mem::transmute(use_128x128_superblock) };
            use_128x128_superblock as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let enable_filter_intra: u32 = unsafe { ::std::mem::transmute(enable_filter_intra) };
            enable_filter_intra as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let enable_intra_edge_filter: u32 =
                unsafe { ::std::mem::transmute(enable_intra_edge_filter) };
            enable_intra_edge_filter as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let enable_interintra_compound: u32 =
                unsafe { ::std::mem::transmute(enable_interintra_compound) };
            enable_interintra_compound as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let enable_masked_compound: u32 =
                unsafe { ::std::mem::transmute(enable_masked_compound) };
            enable_masked_compound as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let enable_dual_filter: u32 = unsafe { ::std::mem::transmute(enable_dual_filter) };
            enable_dual_filter as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let enable_order_hint: u32 = unsafe { ::std::mem::transmute(enable_order_hint) };
            enable_order_hint as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let enable_jnt_comp: u32 = unsafe { ::std::mem::transmute(enable_jnt_comp) };
            enable_jnt_comp as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let enable_cdef: u32 = unsafe { ::std::mem::transmute(enable_cdef) };
            enable_cdef as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let mono_chrome: u32 = unsafe { ::std::mem::transmute(mono_chrome) };
            mono_chrome as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let color_range: u32 = unsafe { ::std::mem::transmute(color_range) };
            color_range as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let subsampling_x: u32 = unsafe { ::std::mem::transmute(subsampling_x) };
            subsampling_x as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let subsampling_y: u32 = unsafe { ::std::mem::transmute(subsampling_y) };
            subsampling_y as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let chroma_sample_position: u32 =
                unsafe { ::std::mem::transmute(chroma_sample_position) };
            chroma_sample_position as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let film_grain_params_present: u32 =
                unsafe { ::std::mem::transmute(film_grain_params_present) };
            film_grain_params_present as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _VADecPictureParameterBufferAV1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _VADecPictureParameterBufferAV1__bindgen_ty_2 {
    pub bits: _VADecPictureParameterBufferAV1__bindgen_ty_2__bindgen_ty_1,
    pub value: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VADecPictureParameterBufferAV1__bindgen_ty_2__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _VADecPictureParameterBufferAV1__bindgen_ty_2__bindgen_ty_1 {
    #[inline]
    pub fn frame_type(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_frame_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn show_frame(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_show_frame(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn showable_frame(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_showable_frame(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn error_resilient_mode(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_error_resilient_mode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn disable_cdf_update(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disable_cdf_update(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn allow_screen_content_tools(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_allow_screen_content_tools(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn force_integer_mv(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_force_integer_mv(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn allow_intrabc(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_allow_intrabc(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn use_superres(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_use_superres(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn allow_high_precision_mv(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_allow_high_precision_mv(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_motion_mode_switchable(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_motion_mode_switchable(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn use_ref_frame_mvs(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_use_ref_frame_mvs(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn disable_frame_end_update_cdf(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disable_frame_end_update_cdf(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn uniform_tile_spacing_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_uniform_tile_spacing_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn allow_warped_motion(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_allow_warped_motion(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn large_scale_tile(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_large_scale_tile(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 15u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        frame_type: u32,
        show_frame: u32,
        showable_frame: u32,
        error_resilient_mode: u32,
        disable_cdf_update: u32,
        allow_screen_content_tools: u32,
        force_integer_mv: u32,
        allow_intrabc: u32,
        use_superres: u32,
        allow_high_precision_mv: u32,
        is_motion_mode_switchable: u32,
        use_ref_frame_mvs: u32,
        disable_frame_end_update_cdf: u32,
        uniform_tile_spacing_flag: u32,
        allow_warped_motion: u32,
        large_scale_tile: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let frame_type: u32 = unsafe { ::std::mem::transmute(frame_type) };
            frame_type as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let show_frame: u32 = unsafe { ::std::mem::transmute(show_frame) };
            show_frame as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let showable_frame: u32 = unsafe { ::std::mem::transmute(showable_frame) };
            showable_frame as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let error_resilient_mode: u32 = unsafe { ::std::mem::transmute(error_resilient_mode) };
            error_resilient_mode as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let disable_cdf_update: u32 = unsafe { ::std::mem::transmute(disable_cdf_update) };
            disable_cdf_update as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let allow_screen_content_tools: u32 =
                unsafe { ::std::mem::transmute(allow_screen_content_tools) };
            allow_screen_content_tools as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let force_integer_mv: u32 = unsafe { ::std::mem::transmute(force_integer_mv) };
            force_integer_mv as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let allow_intrabc: u32 = unsafe { ::std::mem::transmute(allow_intrabc) };
            allow_intrabc as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let use_superres: u32 = unsafe { ::std::mem::transmute(use_superres) };
            use_superres as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let allow_high_precision_mv: u32 =
                unsafe { ::std::mem::transmute(allow_high_precision_mv) };
            allow_high_precision_mv as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let is_motion_mode_switchable: u32 =
                unsafe { ::std::mem::transmute(is_motion_mode_switchable) };
            is_motion_mode_switchable as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let use_ref_frame_mvs: u32 = unsafe { ::std::mem::transmute(use_ref_frame_mvs) };
            use_ref_frame_mvs as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let disable_frame_end_update_cdf: u32 =
                unsafe { ::std::mem::transmute(disable_frame_end_update_cdf) };
            disable_frame_end_update_cdf as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let uniform_tile_spacing_flag: u32 =
                unsafe { ::std::mem::transmute(uniform_tile_spacing_flag) };
            uniform_tile_spacing_flag as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let allow_warped_motion: u32 = unsafe { ::std::mem::transmute(allow_warped_motion) };
            allow_warped_motion as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let large_scale_tile: u32 = unsafe { ::std::mem::transmute(large_scale_tile) };
            large_scale_tile as u64
        });
        __bindgen_bitfield_unit.set(17usize, 15u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _VADecPictureParameterBufferAV1__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _VADecPictureParameterBufferAV1__bindgen_ty_3 {
    pub bits: _VADecPictureParameterBufferAV1__bindgen_ty_3__bindgen_ty_1,
    pub value: u8,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VADecPictureParameterBufferAV1__bindgen_ty_3__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl _VADecPictureParameterBufferAV1__bindgen_ty_3__bindgen_ty_1 {
    #[inline]
    pub fn sharpness_level(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_sharpness_level(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn mode_ref_delta_enabled(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mode_ref_delta_enabled(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mode_ref_delta_update(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mode_ref_delta_update(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        sharpness_level: u8,
        mode_ref_delta_enabled: u8,
        mode_ref_delta_update: u8,
        reserved: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let sharpness_level: u8 = unsafe { ::std::mem::transmute(sharpness_level) };
            sharpness_level as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let mode_ref_delta_enabled: u8 =
                unsafe { ::std::mem::transmute(mode_ref_delta_enabled) };
            mode_ref_delta_enabled as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let mode_ref_delta_update: u8 = unsafe { ::std::mem::transmute(mode_ref_delta_update) };
            mode_ref_delta_update as u64
        });
        __bindgen_bitfield_unit.set(5usize, 3u8, {
            let reserved: u8 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _VADecPictureParameterBufferAV1__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _VADecPictureParameterBufferAV1__bindgen_ty_4 {
    pub bits: _VADecPictureParameterBufferAV1__bindgen_ty_4__bindgen_ty_1,
    pub value: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VADecPictureParameterBufferAV1__bindgen_ty_4__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl _VADecPictureParameterBufferAV1__bindgen_ty_4__bindgen_ty_1 {
    #[inline]
    pub fn using_qmatrix(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_using_qmatrix(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn qm_y(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_qm_y(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn qm_u(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_qm_u(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn qm_v(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_qm_v(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        using_qmatrix: u16,
        qm_y: u16,
        qm_u: u16,
        qm_v: u16,
        reserved: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let using_qmatrix: u16 = unsafe { ::std::mem::transmute(using_qmatrix) };
            using_qmatrix as u64
        });
        __bindgen_bitfield_unit.set(1usize, 4u8, {
            let qm_y: u16 = unsafe { ::std::mem::transmute(qm_y) };
            qm_y as u64
        });
        __bindgen_bitfield_unit.set(5usize, 4u8, {
            let qm_u: u16 = unsafe { ::std::mem::transmute(qm_u) };
            qm_u as u64
        });
        __bindgen_bitfield_unit.set(9usize, 4u8, {
            let qm_v: u16 = unsafe { ::std::mem::transmute(qm_v) };
            qm_v as u64
        });
        __bindgen_bitfield_unit.set(13usize, 3u8, {
            let reserved: u16 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _VADecPictureParameterBufferAV1__bindgen_ty_4 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _VADecPictureParameterBufferAV1__bindgen_ty_5 {
    pub bits: _VADecPictureParameterBufferAV1__bindgen_ty_5__bindgen_ty_1,
    pub value: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VADecPictureParameterBufferAV1__bindgen_ty_5__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _VADecPictureParameterBufferAV1__bindgen_ty_5__bindgen_ty_1 {
    #[inline]
    pub fn delta_q_present_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_delta_q_present_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn log2_delta_q_res(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_log2_delta_q_res(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn delta_lf_present_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_delta_lf_present_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn log2_delta_lf_res(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_log2_delta_lf_res(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn delta_lf_multi(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_delta_lf_multi(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_mode(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_tx_mode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn reference_select(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reference_select(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reduced_tx_set_used(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reduced_tx_set_used(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn skip_mode_present(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_skip_mode_present(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        delta_q_present_flag: u32,
        log2_delta_q_res: u32,
        delta_lf_present_flag: u32,
        log2_delta_lf_res: u32,
        delta_lf_multi: u32,
        tx_mode: u32,
        reference_select: u32,
        reduced_tx_set_used: u32,
        skip_mode_present: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let delta_q_present_flag: u32 = unsafe { ::std::mem::transmute(delta_q_present_flag) };
            delta_q_present_flag as u64
        });
        __bindgen_bitfield_unit.set(1usize, 2u8, {
            let log2_delta_q_res: u32 = unsafe { ::std::mem::transmute(log2_delta_q_res) };
            log2_delta_q_res as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let delta_lf_present_flag: u32 =
                unsafe { ::std::mem::transmute(delta_lf_present_flag) };
            delta_lf_present_flag as u64
        });
        __bindgen_bitfield_unit.set(4usize, 2u8, {
            let log2_delta_lf_res: u32 = unsafe { ::std::mem::transmute(log2_delta_lf_res) };
            log2_delta_lf_res as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let delta_lf_multi: u32 = unsafe { ::std::mem::transmute(delta_lf_multi) };
            delta_lf_multi as u64
        });
        __bindgen_bitfield_unit.set(7usize, 2u8, {
            let tx_mode: u32 = unsafe { ::std::mem::transmute(tx_mode) };
            tx_mode as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let reference_select: u32 = unsafe { ::std::mem::transmute(reference_select) };
            reference_select as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let reduced_tx_set_used: u32 = unsafe { ::std::mem::transmute(reduced_tx_set_used) };
            reduced_tx_set_used as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let skip_mode_present: u32 = unsafe { ::std::mem::transmute(skip_mode_present) };
            skip_mode_present as u64
        });
        __bindgen_bitfield_unit.set(12usize, 20u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _VADecPictureParameterBufferAV1__bindgen_ty_5 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _VADecPictureParameterBufferAV1__bindgen_ty_6 {
    pub bits: _VADecPictureParameterBufferAV1__bindgen_ty_6__bindgen_ty_1,
    pub value: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VADecPictureParameterBufferAV1__bindgen_ty_6__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl _VADecPictureParameterBufferAV1__bindgen_ty_6__bindgen_ty_1 {
    #[inline]
    pub fn yframe_restoration_type(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_yframe_restoration_type(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn cbframe_restoration_type(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_cbframe_restoration_type(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn crframe_restoration_type(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_crframe_restoration_type(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn lr_unit_shift(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_lr_unit_shift(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn lr_uv_shift(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_lr_uv_shift(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 7u8) as u16) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        yframe_restoration_type: u16,
        cbframe_restoration_type: u16,
        crframe_restoration_type: u16,
        lr_unit_shift: u16,
        lr_uv_shift: u16,
        reserved: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let yframe_restoration_type: u16 =
                unsafe { ::std::mem::transmute(yframe_restoration_type) };
            yframe_restoration_type as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let cbframe_restoration_type: u16 =
                unsafe { ::std::mem::transmute(cbframe_restoration_type) };
            cbframe_restoration_type as u64
        });
        __bindgen_bitfield_unit.set(4usize, 2u8, {
            let crframe_restoration_type: u16 =
                unsafe { ::std::mem::transmute(crframe_restoration_type) };
            crframe_restoration_type as u64
        });
        __bindgen_bitfield_unit.set(6usize, 2u8, {
            let lr_unit_shift: u16 = unsafe { ::std::mem::transmute(lr_unit_shift) };
            lr_unit_shift as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let lr_uv_shift: u16 = unsafe { ::std::mem::transmute(lr_uv_shift) };
            lr_uv_shift as u64
        });
        __bindgen_bitfield_unit.set(9usize, 7u8, {
            let reserved: u16 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _VADecPictureParameterBufferAV1__bindgen_ty_6 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _VADecPictureParameterBufferAV1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type VADecPictureParameterBufferAV1 = _VADecPictureParameterBufferAV1;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VASliceParameterBufferAV1 {
    pub slice_data_size: u32,
    pub slice_data_offset: u32,
    pub slice_data_flag: u32,
    pub tile_row: u16,
    pub tile_column: u16,
    pub tg_start: u16,
    pub tg_end: u16,
    pub anchor_frame_idx: u8,
    pub tile_idx_in_tile_list: u16,
    pub va_reserved: [u32; 4usize],
}
pub type VASliceParameterBufferAV1 = _VASliceParameterBufferAV1;
#[repr(C)]
#[derive(Copy, Clone)]
pub union VAConfigAttribValEncHEVCFeatures {
    pub bits: VAConfigAttribValEncHEVCFeatures__bindgen_ty_1,
    pub value: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct VAConfigAttribValEncHEVCFeatures__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl VAConfigAttribValEncHEVCFeatures__bindgen_ty_1 {
    #[inline]
    pub fn separate_colour_planes(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_separate_colour_planes(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn scaling_lists(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_scaling_lists(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn amp(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_amp(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn sao(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_sao(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn pcm(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_pcm(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn temporal_mvp(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_temporal_mvp(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn strong_intra_smoothing(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_strong_intra_smoothing(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn dependent_slices(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_dependent_slices(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn sign_data_hiding(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_sign_data_hiding(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn constrained_intra_pred(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_constrained_intra_pred(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn transform_skip(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_transform_skip(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn cu_qp_delta(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(22usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_cu_qp_delta(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(22usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn weighted_prediction(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_weighted_prediction(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn transquant_bypass(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(26usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_transquant_bypass(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(26usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn deblocking_filter_disable(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(28usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_deblocking_filter_disable(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(28usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(30usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(30usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        separate_colour_planes: u32,
        scaling_lists: u32,
        amp: u32,
        sao: u32,
        pcm: u32,
        temporal_mvp: u32,
        strong_intra_smoothing: u32,
        dependent_slices: u32,
        sign_data_hiding: u32,
        constrained_intra_pred: u32,
        transform_skip: u32,
        cu_qp_delta: u32,
        weighted_prediction: u32,
        transquant_bypass: u32,
        deblocking_filter_disable: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let separate_colour_planes: u32 =
                unsafe { ::std::mem::transmute(separate_colour_planes) };
            separate_colour_planes as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let scaling_lists: u32 = unsafe { ::std::mem::transmute(scaling_lists) };
            scaling_lists as u64
        });
        __bindgen_bitfield_unit.set(4usize, 2u8, {
            let amp: u32 = unsafe { ::std::mem::transmute(amp) };
            amp as u64
        });
        __bindgen_bitfield_unit.set(6usize, 2u8, {
            let sao: u32 = unsafe { ::std::mem::transmute(sao) };
            sao as u64
        });
        __bindgen_bitfield_unit.set(8usize, 2u8, {
            let pcm: u32 = unsafe { ::std::mem::transmute(pcm) };
            pcm as u64
        });
        __bindgen_bitfield_unit.set(10usize, 2u8, {
            let temporal_mvp: u32 = unsafe { ::std::mem::transmute(temporal_mvp) };
            temporal_mvp as u64
        });
        __bindgen_bitfield_unit.set(12usize, 2u8, {
            let strong_intra_smoothing: u32 =
                unsafe { ::std::mem::transmute(strong_intra_smoothing) };
            strong_intra_smoothing as u64
        });
        __bindgen_bitfield_unit.set(14usize, 2u8, {
            let dependent_slices: u32 = unsafe { ::std::mem::transmute(dependent_slices) };
            dependent_slices as u64
        });
        __bindgen_bitfield_unit.set(16usize, 2u8, {
            let sign_data_hiding: u32 = unsafe { ::std::mem::transmute(sign_data_hiding) };
            sign_data_hiding as u64
        });
        __bindgen_bitfield_unit.set(18usize, 2u8, {
            let constrained_intra_pred: u32 =
                unsafe { ::std::mem::transmute(constrained_intra_pred) };
            constrained_intra_pred as u64
        });
        __bindgen_bitfield_unit.set(20usize, 2u8, {
            let transform_skip: u32 = unsafe { ::std::mem::transmute(transform_skip) };
            transform_skip as u64
        });
        __bindgen_bitfield_unit.set(22usize, 2u8, {
            let cu_qp_delta: u32 = unsafe { ::std::mem::transmute(cu_qp_delta) };
            cu_qp_delta as u64
        });
        __bindgen_bitfield_unit.set(24usize, 2u8, {
            let weighted_prediction: u32 = unsafe { ::std::mem::transmute(weighted_prediction) };
            weighted_prediction as u64
        });
        __bindgen_bitfield_unit.set(26usize, 2u8, {
            let transquant_bypass: u32 = unsafe { ::std::mem::transmute(transquant_bypass) };
            transquant_bypass as u64
        });
        __bindgen_bitfield_unit.set(28usize, 2u8, {
            let deblocking_filter_disable: u32 =
                unsafe { ::std::mem::transmute(deblocking_filter_disable) };
            deblocking_filter_disable as u64
        });
        __bindgen_bitfield_unit.set(30usize, 2u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for VAConfigAttribValEncHEVCFeatures {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union VAConfigAttribValEncHEVCBlockSizes {
    pub bits: VAConfigAttribValEncHEVCBlockSizes__bindgen_ty_1,
    pub value: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct VAConfigAttribValEncHEVCBlockSizes__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl VAConfigAttribValEncHEVCBlockSizes__bindgen_ty_1 {
    #[inline]
    pub fn log2_max_coding_tree_block_size_minus3(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_log2_max_coding_tree_block_size_minus3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn log2_min_coding_tree_block_size_minus3(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_log2_min_coding_tree_block_size_minus3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn log2_min_luma_coding_block_size_minus3(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_log2_min_luma_coding_block_size_minus3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn log2_max_luma_transform_block_size_minus2(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_log2_max_luma_transform_block_size_minus2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn log2_min_luma_transform_block_size_minus2(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_log2_min_luma_transform_block_size_minus2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn max_max_transform_hierarchy_depth_inter(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_max_max_transform_hierarchy_depth_inter(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn min_max_transform_hierarchy_depth_inter(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_min_max_transform_hierarchy_depth_inter(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn max_max_transform_hierarchy_depth_intra(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_max_max_transform_hierarchy_depth_intra(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn min_max_transform_hierarchy_depth_intra(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_min_max_transform_hierarchy_depth_intra(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn log2_max_pcm_coding_block_size_minus3(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_log2_max_pcm_coding_block_size_minus3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn log2_min_pcm_coding_block_size_minus3(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_log2_min_pcm_coding_block_size_minus3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(22usize, 10u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(22usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        log2_max_coding_tree_block_size_minus3: u32,
        log2_min_coding_tree_block_size_minus3: u32,
        log2_min_luma_coding_block_size_minus3: u32,
        log2_max_luma_transform_block_size_minus2: u32,
        log2_min_luma_transform_block_size_minus2: u32,
        max_max_transform_hierarchy_depth_inter: u32,
        min_max_transform_hierarchy_depth_inter: u32,
        max_max_transform_hierarchy_depth_intra: u32,
        min_max_transform_hierarchy_depth_intra: u32,
        log2_max_pcm_coding_block_size_minus3: u32,
        log2_min_pcm_coding_block_size_minus3: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let log2_max_coding_tree_block_size_minus3: u32 =
                unsafe { ::std::mem::transmute(log2_max_coding_tree_block_size_minus3) };
            log2_max_coding_tree_block_size_minus3 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let log2_min_coding_tree_block_size_minus3: u32 =
                unsafe { ::std::mem::transmute(log2_min_coding_tree_block_size_minus3) };
            log2_min_coding_tree_block_size_minus3 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 2u8, {
            let log2_min_luma_coding_block_size_minus3: u32 =
                unsafe { ::std::mem::transmute(log2_min_luma_coding_block_size_minus3) };
            log2_min_luma_coding_block_size_minus3 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 2u8, {
            let log2_max_luma_transform_block_size_minus2: u32 =
                unsafe { ::std::mem::transmute(log2_max_luma_transform_block_size_minus2) };
            log2_max_luma_transform_block_size_minus2 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 2u8, {
            let log2_min_luma_transform_block_size_minus2: u32 =
                unsafe { ::std::mem::transmute(log2_min_luma_transform_block_size_minus2) };
            log2_min_luma_transform_block_size_minus2 as u64
        });
        __bindgen_bitfield_unit.set(10usize, 2u8, {
            let max_max_transform_hierarchy_depth_inter: u32 =
                unsafe { ::std::mem::transmute(max_max_transform_hierarchy_depth_inter) };
            max_max_transform_hierarchy_depth_inter as u64
        });
        __bindgen_bitfield_unit.set(12usize, 2u8, {
            let min_max_transform_hierarchy_depth_inter: u32 =
                unsafe { ::std::mem::transmute(min_max_transform_hierarchy_depth_inter) };
            min_max_transform_hierarchy_depth_inter as u64
        });
        __bindgen_bitfield_unit.set(14usize, 2u8, {
            let max_max_transform_hierarchy_depth_intra: u32 =
                unsafe { ::std::mem::transmute(max_max_transform_hierarchy_depth_intra) };
            max_max_transform_hierarchy_depth_intra as u64
        });
        __bindgen_bitfield_unit.set(16usize, 2u8, {
            let min_max_transform_hierarchy_depth_intra: u32 =
                unsafe { ::std::mem::transmute(min_max_transform_hierarchy_depth_intra) };
            min_max_transform_hierarchy_depth_intra as u64
        });
        __bindgen_bitfield_unit.set(18usize, 2u8, {
            let log2_max_pcm_coding_block_size_minus3: u32 =
                unsafe { ::std::mem::transmute(log2_max_pcm_coding_block_size_minus3) };
            log2_max_pcm_coding_block_size_minus3 as u64
        });
        __bindgen_bitfield_unit.set(20usize, 2u8, {
            let log2_min_pcm_coding_block_size_minus3: u32 =
                unsafe { ::std::mem::transmute(log2_min_pcm_coding_block_size_minus3) };
            log2_min_pcm_coding_block_size_minus3 as u64
        });
        __bindgen_bitfield_unit.set(22usize, 10u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for VAConfigAttribValEncHEVCBlockSizes {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod VAEncPackedHeaderTypeHEVC {
    pub type Type = ::std::os::raw::c_uint;
    pub const VAEncPackedHeaderHEVC_VPS: Type = 1;
    pub const VAEncPackedHeaderHEVC_SPS: Type = 1;
    pub const VAEncPackedHeaderHEVC_PPS: Type = 2;
    pub const VAEncPackedHeaderHEVC_Slice: Type = 3;
    pub const VAEncPackedHeaderHEVC_SEI: Type = 2147483649;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _VAEncSequenceParameterBufferHEVC {
    pub general_profile_idc: u8,
    pub general_level_idc: u8,
    pub general_tier_flag: u8,
    pub intra_period: u32,
    pub intra_idr_period: u32,
    pub ip_period: u32,
    pub bits_per_second: u32,
    pub pic_width_in_luma_samples: u16,
    pub pic_height_in_luma_samples: u16,
    pub seq_fields: _VAEncSequenceParameterBufferHEVC__bindgen_ty_1,
    pub log2_min_luma_coding_block_size_minus3: u8,
    pub log2_diff_max_min_luma_coding_block_size: u8,
    pub log2_min_transform_block_size_minus2: u8,
    pub log2_diff_max_min_transform_block_size: u8,
    pub max_transform_hierarchy_depth_inter: u8,
    pub max_transform_hierarchy_depth_intra: u8,
    pub pcm_sample_bit_depth_luma_minus1: u32,
    pub pcm_sample_bit_depth_chroma_minus1: u32,
    pub log2_min_pcm_luma_coding_block_size_minus3: u32,
    pub log2_max_pcm_luma_coding_block_size_minus3: u32,
    pub vui_parameters_present_flag: u8,
    pub vui_fields: _VAEncSequenceParameterBufferHEVC__bindgen_ty_2,
    pub aspect_ratio_idc: u8,
    pub sar_width: u32,
    pub sar_height: u32,
    pub vui_num_units_in_tick: u32,
    pub vui_time_scale: u32,
    pub min_spatial_segmentation_idc: u16,
    pub max_bytes_per_pic_denom: u8,
    pub max_bits_per_min_cu_denom: u8,
    pub scc_fields: _VAEncSequenceParameterBufferHEVC__bindgen_ty_3,
    pub va_reserved: [u32; 7usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _VAEncSequenceParameterBufferHEVC__bindgen_ty_1 {
    pub bits: _VAEncSequenceParameterBufferHEVC__bindgen_ty_1__bindgen_ty_1,
    pub value: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VAEncSequenceParameterBufferHEVC__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _VAEncSequenceParameterBufferHEVC__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn chroma_format_idc(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_chroma_format_idc(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn separate_colour_plane_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_separate_colour_plane_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bit_depth_luma_minus8(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_bit_depth_luma_minus8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn bit_depth_chroma_minus8(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_bit_depth_chroma_minus8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn scaling_list_enabled_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scaling_list_enabled_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn strong_intra_smoothing_enabled_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_strong_intra_smoothing_enabled_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn amp_enabled_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_amp_enabled_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sample_adaptive_offset_enabled_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sample_adaptive_offset_enabled_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pcm_enabled_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pcm_enabled_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pcm_loop_filter_disabled_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pcm_loop_filter_disabled_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sps_temporal_mvp_enabled_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sps_temporal_mvp_enabled_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn low_delay_seq(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_low_delay_seq(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hierachical_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hierachical_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved_bits(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 14u8) as u32) }
    }
    #[inline]
    pub fn set_reserved_bits(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 14u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        chroma_format_idc: u32,
        separate_colour_plane_flag: u32,
        bit_depth_luma_minus8: u32,
        bit_depth_chroma_minus8: u32,
        scaling_list_enabled_flag: u32,
        strong_intra_smoothing_enabled_flag: u32,
        amp_enabled_flag: u32,
        sample_adaptive_offset_enabled_flag: u32,
        pcm_enabled_flag: u32,
        pcm_loop_filter_disabled_flag: u32,
        sps_temporal_mvp_enabled_flag: u32,
        low_delay_seq: u32,
        hierachical_flag: u32,
        reserved_bits: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let chroma_format_idc: u32 = unsafe { ::std::mem::transmute(chroma_format_idc) };
            chroma_format_idc as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let separate_colour_plane_flag: u32 =
                unsafe { ::std::mem::transmute(separate_colour_plane_flag) };
            separate_colour_plane_flag as u64
        });
        __bindgen_bitfield_unit.set(3usize, 3u8, {
            let bit_depth_luma_minus8: u32 =
                unsafe { ::std::mem::transmute(bit_depth_luma_minus8) };
            bit_depth_luma_minus8 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 3u8, {
            let bit_depth_chroma_minus8: u32 =
                unsafe { ::std::mem::transmute(bit_depth_chroma_minus8) };
            bit_depth_chroma_minus8 as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let scaling_list_enabled_flag: u32 =
                unsafe { ::std::mem::transmute(scaling_list_enabled_flag) };
            scaling_list_enabled_flag as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let strong_intra_smoothing_enabled_flag: u32 =
                unsafe { ::std::mem::transmute(strong_intra_smoothing_enabled_flag) };
            strong_intra_smoothing_enabled_flag as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let amp_enabled_flag: u32 = unsafe { ::std::mem::transmute(amp_enabled_flag) };
            amp_enabled_flag as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let sample_adaptive_offset_enabled_flag: u32 =
                unsafe { ::std::mem::transmute(sample_adaptive_offset_enabled_flag) };
            sample_adaptive_offset_enabled_flag as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let pcm_enabled_flag: u32 = unsafe { ::std::mem::transmute(pcm_enabled_flag) };
            pcm_enabled_flag as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let pcm_loop_filter_disabled_flag: u32 =
                unsafe { ::std::mem::transmute(pcm_loop_filter_disabled_flag) };
            pcm_loop_filter_disabled_flag as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let sps_temporal_mvp_enabled_flag: u32 =
                unsafe { ::std::mem::transmute(sps_temporal_mvp_enabled_flag) };
            sps_temporal_mvp_enabled_flag as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let low_delay_seq: u32 = unsafe { ::std::mem::transmute(low_delay_seq) };
            low_delay_seq as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let hierachical_flag: u32 = unsafe { ::std::mem::transmute(hierachical_flag) };
            hierachical_flag as u64
        });
        __bindgen_bitfield_unit.set(18usize, 14u8, {
            let reserved_bits: u32 = unsafe { ::std::mem::transmute(reserved_bits) };
            reserved_bits as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _VAEncSequenceParameterBufferHEVC__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _VAEncSequenceParameterBufferHEVC__bindgen_ty_2 {
    pub bits: _VAEncSequenceParameterBufferHEVC__bindgen_ty_2__bindgen_ty_1,
    pub value: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VAEncSequenceParameterBufferHEVC__bindgen_ty_2__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize]>,
    pub __bindgen_padding_0: u8,
}
impl _VAEncSequenceParameterBufferHEVC__bindgen_ty_2__bindgen_ty_1 {
    #[inline]
    pub fn aspect_ratio_info_present_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_aspect_ratio_info_present_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn neutral_chroma_indication_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_neutral_chroma_indication_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn field_seq_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_field_seq_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn vui_timing_info_present_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_vui_timing_info_present_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bitstream_restriction_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bitstream_restriction_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tiles_fixed_structure_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tiles_fixed_structure_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn motion_vectors_over_pic_boundaries_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_motion_vectors_over_pic_boundaries_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn restricted_ref_pic_lists_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_restricted_ref_pic_lists_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn log2_max_mv_length_horizontal(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_log2_max_mv_length_horizontal(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn log2_max_mv_length_vertical(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_log2_max_mv_length_vertical(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        aspect_ratio_info_present_flag: u32,
        neutral_chroma_indication_flag: u32,
        field_seq_flag: u32,
        vui_timing_info_present_flag: u32,
        bitstream_restriction_flag: u32,
        tiles_fixed_structure_flag: u32,
        motion_vectors_over_pic_boundaries_flag: u32,
        restricted_ref_pic_lists_flag: u32,
        log2_max_mv_length_horizontal: u32,
        log2_max_mv_length_vertical: u32,
    ) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let aspect_ratio_info_present_flag: u32 =
                unsafe { ::std::mem::transmute(aspect_ratio_info_present_flag) };
            aspect_ratio_info_present_flag as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let neutral_chroma_indication_flag: u32 =
                unsafe { ::std::mem::transmute(neutral_chroma_indication_flag) };
            neutral_chroma_indication_flag as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let field_seq_flag: u32 = unsafe { ::std::mem::transmute(field_seq_flag) };
            field_seq_flag as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let vui_timing_info_present_flag: u32 =
                unsafe { ::std::mem::transmute(vui_timing_info_present_flag) };
            vui_timing_info_present_flag as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let bitstream_restriction_flag: u32 =
                unsafe { ::std::mem::transmute(bitstream_restriction_flag) };
            bitstream_restriction_flag as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let tiles_fixed_structure_flag: u32 =
                unsafe { ::std::mem::transmute(tiles_fixed_structure_flag) };
            tiles_fixed_structure_flag as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let motion_vectors_over_pic_boundaries_flag: u32 =
                unsafe { ::std::mem::transmute(motion_vectors_over_pic_boundaries_flag) };
            motion_vectors_over_pic_boundaries_flag as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let restricted_ref_pic_lists_flag: u32 =
                unsafe { ::std::mem::transmute(restricted_ref_pic_lists_flag) };
            restricted_ref_pic_lists_flag as u64
        });
        __bindgen_bitfield_unit.set(8usize, 5u8, {
            let log2_max_mv_length_horizontal: u32 =
                unsafe { ::std::mem::transmute(log2_max_mv_length_horizontal) };
            log2_max_mv_length_horizontal as u64
        });
        __bindgen_bitfield_unit.set(13usize, 5u8, {
            let log2_max_mv_length_vertical: u32 =
                unsafe { ::std::mem::transmute(log2_max_mv_length_vertical) };
            log2_max_mv_length_vertical as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _VAEncSequenceParameterBufferHEVC__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _VAEncSequenceParameterBufferHEVC__bindgen_ty_3 {
    pub bits: _VAEncSequenceParameterBufferHEVC__bindgen_ty_3__bindgen_ty_1,
    pub value: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VAEncSequenceParameterBufferHEVC__bindgen_ty_3__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _VAEncSequenceParameterBufferHEVC__bindgen_ty_3__bindgen_ty_1 {
    #[inline]
    pub fn palette_mode_enabled_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_palette_mode_enabled_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        palette_mode_enabled_flag: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let palette_mode_enabled_flag: u32 =
                unsafe { ::std::mem::transmute(palette_mode_enabled_flag) };
            palette_mode_enabled_flag as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _VAEncSequenceParameterBufferHEVC__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _VAEncSequenceParameterBufferHEVC {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type VAEncSequenceParameterBufferHEVC = _VAEncSequenceParameterBufferHEVC;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _VAEncPictureParameterBufferHEVC {
    pub decoded_curr_pic: VAPictureHEVC,
    pub reference_frames: [VAPictureHEVC; 15usize],
    pub coded_buf: VABufferID,
    pub collocated_ref_pic_index: u8,
    pub last_picture: u8,
    pub pic_init_qp: u8,
    pub diff_cu_qp_delta_depth: u8,
    pub pps_cb_qp_offset: i8,
    pub pps_cr_qp_offset: i8,
    pub num_tile_columns_minus1: u8,
    pub num_tile_rows_minus1: u8,
    pub column_width_minus1: [u8; 19usize],
    pub row_height_minus1: [u8; 21usize],
    pub log2_parallel_merge_level_minus2: u8,
    pub ctu_max_bitsize_allowed: u8,
    pub num_ref_idx_l0_default_active_minus1: u8,
    pub num_ref_idx_l1_default_active_minus1: u8,
    pub slice_pic_parameter_set_id: u8,
    pub nal_unit_type: u8,
    pub pic_fields: _VAEncPictureParameterBufferHEVC__bindgen_ty_1,
    pub hierarchical_level_plus1: u8,
    pub va_byte_reserved: u8,
    pub scc_fields: _VAEncPictureParameterBufferHEVC__bindgen_ty_2,
    pub va_reserved: [u32; 15usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _VAEncPictureParameterBufferHEVC__bindgen_ty_1 {
    pub bits: _VAEncPictureParameterBufferHEVC__bindgen_ty_1__bindgen_ty_1,
    pub value: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VAEncPictureParameterBufferHEVC__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _VAEncPictureParameterBufferHEVC__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn idr_pic_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_idr_pic_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn coding_type(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_coding_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn reference_pic_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reference_pic_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dependent_slice_segments_enabled_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dependent_slice_segments_enabled_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sign_data_hiding_enabled_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sign_data_hiding_enabled_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn constrained_intra_pred_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_constrained_intra_pred_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn transform_skip_enabled_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_transform_skip_enabled_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cu_qp_delta_enabled_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cu_qp_delta_enabled_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn weighted_pred_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_weighted_pred_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn weighted_bipred_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_weighted_bipred_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn transquant_bypass_enabled_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_transquant_bypass_enabled_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tiles_enabled_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tiles_enabled_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn entropy_coding_sync_enabled_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_entropy_coding_sync_enabled_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn loop_filter_across_tiles_enabled_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_loop_filter_across_tiles_enabled_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pps_loop_filter_across_slices_enabled_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pps_loop_filter_across_slices_enabled_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scaling_list_data_present_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scaling_list_data_present_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn screen_content_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_screen_content_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enable_gpu_weighted_prediction(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enable_gpu_weighted_prediction(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn no_output_of_prior_pics_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_no_output_of_prior_pics_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(21usize, 11u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(21usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        idr_pic_flag: u32,
        coding_type: u32,
        reference_pic_flag: u32,
        dependent_slice_segments_enabled_flag: u32,
        sign_data_hiding_enabled_flag: u32,
        constrained_intra_pred_flag: u32,
        transform_skip_enabled_flag: u32,
        cu_qp_delta_enabled_flag: u32,
        weighted_pred_flag: u32,
        weighted_bipred_flag: u32,
        transquant_bypass_enabled_flag: u32,
        tiles_enabled_flag: u32,
        entropy_coding_sync_enabled_flag: u32,
        loop_filter_across_tiles_enabled_flag: u32,
        pps_loop_filter_across_slices_enabled_flag: u32,
        scaling_list_data_present_flag: u32,
        screen_content_flag: u32,
        enable_gpu_weighted_prediction: u32,
        no_output_of_prior_pics_flag: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let idr_pic_flag: u32 = unsafe { ::std::mem::transmute(idr_pic_flag) };
            idr_pic_flag as u64
        });
        __bindgen_bitfield_unit.set(1usize, 3u8, {
            let coding_type: u32 = unsafe { ::std::mem::transmute(coding_type) };
            coding_type as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let reference_pic_flag: u32 = unsafe { ::std::mem::transmute(reference_pic_flag) };
            reference_pic_flag as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let dependent_slice_segments_enabled_flag: u32 =
                unsafe { ::std::mem::transmute(dependent_slice_segments_enabled_flag) };
            dependent_slice_segments_enabled_flag as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let sign_data_hiding_enabled_flag: u32 =
                unsafe { ::std::mem::transmute(sign_data_hiding_enabled_flag) };
            sign_data_hiding_enabled_flag as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let constrained_intra_pred_flag: u32 =
                unsafe { ::std::mem::transmute(constrained_intra_pred_flag) };
            constrained_intra_pred_flag as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let transform_skip_enabled_flag: u32 =
                unsafe { ::std::mem::transmute(transform_skip_enabled_flag) };
            transform_skip_enabled_flag as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let cu_qp_delta_enabled_flag: u32 =
                unsafe { ::std::mem::transmute(cu_qp_delta_enabled_flag) };
            cu_qp_delta_enabled_flag as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let weighted_pred_flag: u32 = unsafe { ::std::mem::transmute(weighted_pred_flag) };
            weighted_pred_flag as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let weighted_bipred_flag: u32 = unsafe { ::std::mem::transmute(weighted_bipred_flag) };
            weighted_bipred_flag as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let transquant_bypass_enabled_flag: u32 =
                unsafe { ::std::mem::transmute(transquant_bypass_enabled_flag) };
            transquant_bypass_enabled_flag as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let tiles_enabled_flag: u32 = unsafe { ::std::mem::transmute(tiles_enabled_flag) };
            tiles_enabled_flag as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let entropy_coding_sync_enabled_flag: u32 =
                unsafe { ::std::mem::transmute(entropy_coding_sync_enabled_flag) };
            entropy_coding_sync_enabled_flag as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let loop_filter_across_tiles_enabled_flag: u32 =
                unsafe { ::std::mem::transmute(loop_filter_across_tiles_enabled_flag) };
            loop_filter_across_tiles_enabled_flag as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let pps_loop_filter_across_slices_enabled_flag: u32 =
                unsafe { ::std::mem::transmute(pps_loop_filter_across_slices_enabled_flag) };
            pps_loop_filter_across_slices_enabled_flag as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let scaling_list_data_present_flag: u32 =
                unsafe { ::std::mem::transmute(scaling_list_data_present_flag) };
            scaling_list_data_present_flag as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let screen_content_flag: u32 = unsafe { ::std::mem::transmute(screen_content_flag) };
            screen_content_flag as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let enable_gpu_weighted_prediction: u32 =
                unsafe { ::std::mem::transmute(enable_gpu_weighted_prediction) };
            enable_gpu_weighted_prediction as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let no_output_of_prior_pics_flag: u32 =
                unsafe { ::std::mem::transmute(no_output_of_prior_pics_flag) };
            no_output_of_prior_pics_flag as u64
        });
        __bindgen_bitfield_unit.set(21usize, 11u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _VAEncPictureParameterBufferHEVC__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _VAEncPictureParameterBufferHEVC__bindgen_ty_2 {
    pub bits: _VAEncPictureParameterBufferHEVC__bindgen_ty_2__bindgen_ty_1,
    pub value: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VAEncPictureParameterBufferHEVC__bindgen_ty_2__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl _VAEncPictureParameterBufferHEVC__bindgen_ty_2__bindgen_ty_1 {
    #[inline]
    pub fn pps_curr_pic_ref_enabled_flag(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_pps_curr_pic_ref_enabled_flag(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 15u8) as u16) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        pps_curr_pic_ref_enabled_flag: u16,
        reserved: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let pps_curr_pic_ref_enabled_flag: u16 =
                unsafe { ::std::mem::transmute(pps_curr_pic_ref_enabled_flag) };
            pps_curr_pic_ref_enabled_flag as u64
        });
        __bindgen_bitfield_unit.set(1usize, 15u8, {
            let reserved: u16 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _VAEncPictureParameterBufferHEVC__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _VAEncPictureParameterBufferHEVC {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type VAEncPictureParameterBufferHEVC = _VAEncPictureParameterBufferHEVC;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _VAEncSliceParameterBufferHEVC {
    pub slice_segment_address: u32,
    pub num_ctu_in_slice: u32,
    pub slice_type: u8,
    pub slice_pic_parameter_set_id: u8,
    pub num_ref_idx_l0_active_minus1: u8,
    pub num_ref_idx_l1_active_minus1: u8,
    pub ref_pic_list0: [VAPictureHEVC; 15usize],
    pub ref_pic_list1: [VAPictureHEVC; 15usize],
    pub luma_log2_weight_denom: u8,
    pub delta_chroma_log2_weight_denom: i8,
    pub delta_luma_weight_l0: [i8; 15usize],
    pub luma_offset_l0: [i8; 15usize],
    pub delta_chroma_weight_l0: [[i8; 2usize]; 15usize],
    pub chroma_offset_l0: [[i8; 2usize]; 15usize],
    pub delta_luma_weight_l1: [i8; 15usize],
    pub luma_offset_l1: [i8; 15usize],
    pub delta_chroma_weight_l1: [[i8; 2usize]; 15usize],
    pub chroma_offset_l1: [[i8; 2usize]; 15usize],
    pub max_num_merge_cand: u8,
    pub slice_qp_delta: i8,
    pub slice_cb_qp_offset: i8,
    pub slice_cr_qp_offset: i8,
    pub slice_beta_offset_div2: i8,
    pub slice_tc_offset_div2: i8,
    pub slice_fields: _VAEncSliceParameterBufferHEVC__bindgen_ty_1,
    pub pred_weight_table_bit_offset: u32,
    pub pred_weight_table_bit_length: u32,
    pub va_reserved: [u32; 6usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _VAEncSliceParameterBufferHEVC__bindgen_ty_1 {
    pub bits: _VAEncSliceParameterBufferHEVC__bindgen_ty_1__bindgen_ty_1,
    pub value: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VAEncSliceParameterBufferHEVC__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub __bindgen_padding_0: u16,
}
impl _VAEncSliceParameterBufferHEVC__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn last_slice_of_pic_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_last_slice_of_pic_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dependent_slice_segment_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dependent_slice_segment_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn colour_plane_id(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_colour_plane_id(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn slice_temporal_mvp_enabled_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slice_temporal_mvp_enabled_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slice_sao_luma_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slice_sao_luma_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slice_sao_chroma_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slice_sao_chroma_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn num_ref_idx_active_override_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_num_ref_idx_active_override_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mvd_l1_zero_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mvd_l1_zero_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cabac_init_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cabac_init_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slice_deblocking_filter_disabled_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_slice_deblocking_filter_disabled_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn slice_loop_filter_across_slices_enabled_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slice_loop_filter_across_slices_enabled_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn collocated_from_l0_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_collocated_from_l0_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        last_slice_of_pic_flag: u32,
        dependent_slice_segment_flag: u32,
        colour_plane_id: u32,
        slice_temporal_mvp_enabled_flag: u32,
        slice_sao_luma_flag: u32,
        slice_sao_chroma_flag: u32,
        num_ref_idx_active_override_flag: u32,
        mvd_l1_zero_flag: u32,
        cabac_init_flag: u32,
        slice_deblocking_filter_disabled_flag: u32,
        slice_loop_filter_across_slices_enabled_flag: u32,
        collocated_from_l0_flag: u32,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let last_slice_of_pic_flag: u32 =
                unsafe { ::std::mem::transmute(last_slice_of_pic_flag) };
            last_slice_of_pic_flag as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let dependent_slice_segment_flag: u32 =
                unsafe { ::std::mem::transmute(dependent_slice_segment_flag) };
            dependent_slice_segment_flag as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let colour_plane_id: u32 = unsafe { ::std::mem::transmute(colour_plane_id) };
            colour_plane_id as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let slice_temporal_mvp_enabled_flag: u32 =
                unsafe { ::std::mem::transmute(slice_temporal_mvp_enabled_flag) };
            slice_temporal_mvp_enabled_flag as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let slice_sao_luma_flag: u32 = unsafe { ::std::mem::transmute(slice_sao_luma_flag) };
            slice_sao_luma_flag as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let slice_sao_chroma_flag: u32 =
                unsafe { ::std::mem::transmute(slice_sao_chroma_flag) };
            slice_sao_chroma_flag as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let num_ref_idx_active_override_flag: u32 =
                unsafe { ::std::mem::transmute(num_ref_idx_active_override_flag) };
            num_ref_idx_active_override_flag as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let mvd_l1_zero_flag: u32 = unsafe { ::std::mem::transmute(mvd_l1_zero_flag) };
            mvd_l1_zero_flag as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let cabac_init_flag: u32 = unsafe { ::std::mem::transmute(cabac_init_flag) };
            cabac_init_flag as u64
        });
        __bindgen_bitfield_unit.set(10usize, 2u8, {
            let slice_deblocking_filter_disabled_flag: u32 =
                unsafe { ::std::mem::transmute(slice_deblocking_filter_disabled_flag) };
            slice_deblocking_filter_disabled_flag as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let slice_loop_filter_across_slices_enabled_flag: u32 =
                unsafe { ::std::mem::transmute(slice_loop_filter_across_slices_enabled_flag) };
            slice_loop_filter_across_slices_enabled_flag as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let collocated_from_l0_flag: u32 =
                unsafe { ::std::mem::transmute(collocated_from_l0_flag) };
            collocated_from_l0_flag as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _VAEncSliceParameterBufferHEVC__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _VAEncSliceParameterBufferHEVC {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type VAEncSliceParameterBufferHEVC = _VAEncSliceParameterBufferHEVC;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _VAQMatrixBufferHEVC {
    pub scaling_lists_4x4: [[[u8; 16usize]; 2usize]; 3usize],
    pub scaling_lists_8x8: [[[u8; 64usize]; 2usize]; 3usize],
    pub scaling_lists_16x16: [[[u8; 64usize]; 2usize]; 3usize],
    pub scaling_lists_32x32: [[u8; 64usize]; 2usize],
    pub scaling_list_dc_16x16: [[u8; 2usize]; 3usize],
    pub scaling_list_dc_32x32: [u8; 2usize],
    pub va_reserved: [u32; 4usize],
}
impl Default for _VAQMatrixBufferHEVC {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type VAQMatrixBufferHEVC = _VAQMatrixBufferHEVC;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VAPictureStats {
    pub picture_id: VASurfaceID,
    pub flags: u32,
}
pub type VAPictureStats = _VAPictureStats;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _VAStatsStatisticsParameter {
    pub input: VAPictureStats,
    pub past_references: *mut VAPictureStats,
    pub num_past_references: u32,
    pub past_ref_stat_buf: *mut VABufferID,
    pub future_references: *mut VAPictureStats,
    pub num_future_references: u32,
    pub future_ref_stat_buf: *mut VABufferID,
    pub outputs: *mut VABufferID,
    pub mv_predictor: VABufferID,
    pub qp: VABufferID,
}
impl Default for _VAStatsStatisticsParameter {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type VAStatsStatisticsParameter = _VAStatsStatisticsParameter;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _VAEncMiscParameterFEIFrameControlHEVC {
    pub function: u32,
    pub ctb_ctrl: VABufferID,
    pub ctb_cmd: VABufferID,
    pub cu_record: VABufferID,
    pub distortion: VABufferID,
    pub qp: VABufferID,
    pub mv_predictor: VABufferID,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 20usize]>,
    pub max_frame_size: u32,
    pub num_passes: u32,
    pub delta_qp: *mut u8,
    pub reserved4: [u32; 2usize],
}
impl Default for _VAEncMiscParameterFEIFrameControlHEVC {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _VAEncMiscParameterFEIFrameControlHEVC {
    #[inline]
    pub fn num_mv_predictors_l0(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_num_mv_predictors_l0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn num_mv_predictors_l1(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_num_mv_predictors_l1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn search_path(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_search_path(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn len_sp(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(40usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_len_sp(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(40usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(48usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(48usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn multi_pred_l0(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(64usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_multi_pred_l0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(64usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn multi_pred_l1(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(68usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_multi_pred_l1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(68usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn sub_pel_mode(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(72usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_sub_pel_mode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(72usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn adaptive_search(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(74usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_adaptive_search(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(74usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mv_predictor_input(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(75usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_mv_predictor_input(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(75usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn per_block_qp(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(78usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_per_block_qp(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(78usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn per_ctb_input(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(79usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_per_ctb_input(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(79usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn colocated_ctb_distortion(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(80usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_colocated_ctb_distortion(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(80usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn force_lcu_split(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(81usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_force_lcu_split(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(81usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enable_cu64_check(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(82usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enable_cu64_check(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(82usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enable_cu64_amp_check(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(83usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enable_cu64_amp_check(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(83usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cu64_skip_check_only(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(84usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cu64_skip_check_only(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(84usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved1(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(85usize, 11u8) as u32) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(85usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub fn ref_width(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(96usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_ref_width(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(96usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn ref_height(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(104usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_ref_height(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(104usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn search_window(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(112usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_search_window(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(112usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn max_num_ime_search_center(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(120usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_max_num_ime_search_center(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(120usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn fast_intra_mode(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(123usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fast_intra_mode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(123usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved2(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(124usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_reserved2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(124usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn num_concurrent_enc_frame_partition(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(128usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_num_concurrent_enc_frame_partition(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(128usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved3(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(136usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_reserved3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(136usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        num_mv_predictors_l0: u32,
        num_mv_predictors_l1: u32,
        search_path: u32,
        len_sp: u32,
        reserved0: u32,
        multi_pred_l0: u32,
        multi_pred_l1: u32,
        sub_pel_mode: u32,
        adaptive_search: u32,
        mv_predictor_input: u32,
        per_block_qp: u32,
        per_ctb_input: u32,
        colocated_ctb_distortion: u32,
        force_lcu_split: u32,
        enable_cu64_check: u32,
        enable_cu64_amp_check: u32,
        cu64_skip_check_only: u32,
        reserved1: u32,
        ref_width: u32,
        ref_height: u32,
        search_window: u32,
        max_num_ime_search_center: u32,
        fast_intra_mode: u32,
        reserved2: u32,
        num_concurrent_enc_frame_partition: u32,
        reserved3: u32,
    ) -> __BindgenBitfieldUnit<[u8; 20usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 20usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let num_mv_predictors_l0: u32 = unsafe { ::std::mem::transmute(num_mv_predictors_l0) };
            num_mv_predictors_l0 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let num_mv_predictors_l1: u32 = unsafe { ::std::mem::transmute(num_mv_predictors_l1) };
            num_mv_predictors_l1 as u64
        });
        __bindgen_bitfield_unit.set(32usize, 8u8, {
            let search_path: u32 = unsafe { ::std::mem::transmute(search_path) };
            search_path as u64
        });
        __bindgen_bitfield_unit.set(40usize, 8u8, {
            let len_sp: u32 = unsafe { ::std::mem::transmute(len_sp) };
            len_sp as u64
        });
        __bindgen_bitfield_unit.set(48usize, 16u8, {
            let reserved0: u32 = unsafe { ::std::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(64usize, 4u8, {
            let multi_pred_l0: u32 = unsafe { ::std::mem::transmute(multi_pred_l0) };
            multi_pred_l0 as u64
        });
        __bindgen_bitfield_unit.set(68usize, 4u8, {
            let multi_pred_l1: u32 = unsafe { ::std::mem::transmute(multi_pred_l1) };
            multi_pred_l1 as u64
        });
        __bindgen_bitfield_unit.set(72usize, 2u8, {
            let sub_pel_mode: u32 = unsafe { ::std::mem::transmute(sub_pel_mode) };
            sub_pel_mode as u64
        });
        __bindgen_bitfield_unit.set(74usize, 1u8, {
            let adaptive_search: u32 = unsafe { ::std::mem::transmute(adaptive_search) };
            adaptive_search as u64
        });
        __bindgen_bitfield_unit.set(75usize, 3u8, {
            let mv_predictor_input: u32 = unsafe { ::std::mem::transmute(mv_predictor_input) };
            mv_predictor_input as u64
        });
        __bindgen_bitfield_unit.set(78usize, 1u8, {
            let per_block_qp: u32 = unsafe { ::std::mem::transmute(per_block_qp) };
            per_block_qp as u64
        });
        __bindgen_bitfield_unit.set(79usize, 1u8, {
            let per_ctb_input: u32 = unsafe { ::std::mem::transmute(per_ctb_input) };
            per_ctb_input as u64
        });
        __bindgen_bitfield_unit.set(80usize, 1u8, {
            let colocated_ctb_distortion: u32 =
                unsafe { ::std::mem::transmute(colocated_ctb_distortion) };
            colocated_ctb_distortion as u64
        });
        __bindgen_bitfield_unit.set(81usize, 1u8, {
            let force_lcu_split: u32 = unsafe { ::std::mem::transmute(force_lcu_split) };
            force_lcu_split as u64
        });
        __bindgen_bitfield_unit.set(82usize, 1u8, {
            let enable_cu64_check: u32 = unsafe { ::std::mem::transmute(enable_cu64_check) };
            enable_cu64_check as u64
        });
        __bindgen_bitfield_unit.set(83usize, 1u8, {
            let enable_cu64_amp_check: u32 =
                unsafe { ::std::mem::transmute(enable_cu64_amp_check) };
            enable_cu64_amp_check as u64
        });
        __bindgen_bitfield_unit.set(84usize, 1u8, {
            let cu64_skip_check_only: u32 = unsafe { ::std::mem::transmute(cu64_skip_check_only) };
            cu64_skip_check_only as u64
        });
        __bindgen_bitfield_unit.set(85usize, 11u8, {
            let reserved1: u32 = unsafe { ::std::mem::transmute(reserved1) };
            reserved1 as u64
        });
        __bindgen_bitfield_unit.set(96usize, 8u8, {
            let ref_width: u32 = unsafe { ::std::mem::transmute(ref_width) };
            ref_width as u64
        });
        __bindgen_bitfield_unit.set(104usize, 8u8, {
            let ref_height: u32 = unsafe { ::std::mem::transmute(ref_height) };
            ref_height as u64
        });
        __bindgen_bitfield_unit.set(112usize, 8u8, {
            let search_window: u32 = unsafe { ::std::mem::transmute(search_window) };
            search_window as u64
        });
        __bindgen_bitfield_unit.set(120usize, 3u8, {
            let max_num_ime_search_center: u32 =
                unsafe { ::std::mem::transmute(max_num_ime_search_center) };
            max_num_ime_search_center as u64
        });
        __bindgen_bitfield_unit.set(123usize, 1u8, {
            let fast_intra_mode: u32 = unsafe { ::std::mem::transmute(fast_intra_mode) };
            fast_intra_mode as u64
        });
        __bindgen_bitfield_unit.set(124usize, 4u8, {
            let reserved2: u32 = unsafe { ::std::mem::transmute(reserved2) };
            reserved2 as u64
        });
        __bindgen_bitfield_unit.set(128usize, 8u8, {
            let num_concurrent_enc_frame_partition: u32 =
                unsafe { ::std::mem::transmute(num_concurrent_enc_frame_partition) };
            num_concurrent_enc_frame_partition as u64
        });
        __bindgen_bitfield_unit.set(136usize, 24u8, {
            let reserved3: u32 = unsafe { ::std::mem::transmute(reserved3) };
            reserved3 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type VAEncMiscParameterFEIFrameControlHEVC = _VAEncMiscParameterFEIFrameControlHEVC;
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VAEncFEIMVPredictorHEVC {
    pub ref_idx: [_VAEncFEIMVPredictorHEVC__bindgen_ty_1; 4usize],
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub mv: [VAMotionVector; 4usize],
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VAEncFEIMVPredictorHEVC__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl _VAEncFEIMVPredictorHEVC__bindgen_ty_1 {
    #[inline]
    pub fn ref_idx_l0(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_ref_idx_l0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn ref_idx_l1(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_ref_idx_l1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(ref_idx_l0: u8, ref_idx_l1: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let ref_idx_l0: u8 = unsafe { ::std::mem::transmute(ref_idx_l0) };
            ref_idx_l0 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let ref_idx_l1: u8 = unsafe { ::std::mem::transmute(ref_idx_l1) };
            ref_idx_l1 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl _VAEncFEIMVPredictorHEVC {
    #[inline]
    pub fn block_size(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_block_size(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(block_size: u32, reserved: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let block_size: u32 = unsafe { ::std::mem::transmute(block_size) };
            block_size as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type VAEncFEIMVPredictorHEVC = _VAEncFEIMVPredictorHEVC;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VAEncFEICTBControlHEVC {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub reserved1: u32,
    pub reserved2: u32,
    pub reserved3: u32,
}
impl _VAEncFEICTBControlHEVC {
    #[inline]
    pub fn force_to_intra(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_force_to_intra(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn force_to_inter(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_force_to_inter(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn force_to_skip(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_force_to_skip(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn force_to_zero_coeff(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_force_to_zero_coeff(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 28u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 28u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        force_to_intra: u32,
        force_to_inter: u32,
        force_to_skip: u32,
        force_to_zero_coeff: u32,
        reserved0: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let force_to_intra: u32 = unsafe { ::std::mem::transmute(force_to_intra) };
            force_to_intra as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let force_to_inter: u32 = unsafe { ::std::mem::transmute(force_to_inter) };
            force_to_inter as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let force_to_skip: u32 = unsafe { ::std::mem::transmute(force_to_skip) };
            force_to_skip as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let force_to_zero_coeff: u32 = unsafe { ::std::mem::transmute(force_to_zero_coeff) };
            force_to_zero_coeff as u64
        });
        __bindgen_bitfield_unit.set(4usize, 28u8, {
            let reserved0: u32 = unsafe { ::std::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type VAEncFEICTBControlHEVC = _VAEncFEICTBControlHEVC;
pub mod VAEncPackedHeaderTypeH264 {
    pub type Type = ::std::os::raw::c_uint;
    pub const VAEncPackedHeaderH264_SPS: Type = 1;
    pub const VAEncPackedHeaderH264_PPS: Type = 2;
    pub const VAEncPackedHeaderH264_Slice: Type = 3;
    pub const VAEncPackedHeaderH264_SEI: Type = 2147483649;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _VAEncSequenceParameterBufferH264 {
    pub seq_parameter_set_id: u8,
    pub level_idc: u8,
    pub intra_period: u32,
    pub intra_idr_period: u32,
    pub ip_period: u32,
    pub bits_per_second: u32,
    pub max_num_ref_frames: u32,
    pub picture_width_in_mbs: u16,
    pub picture_height_in_mbs: u16,
    pub seq_fields: _VAEncSequenceParameterBufferH264__bindgen_ty_1,
    pub bit_depth_luma_minus8: u8,
    pub bit_depth_chroma_minus8: u8,
    pub num_ref_frames_in_pic_order_cnt_cycle: u8,
    pub offset_for_non_ref_pic: i32,
    pub offset_for_top_to_bottom_field: i32,
    pub offset_for_ref_frame: [i32; 256usize],
    pub frame_cropping_flag: u8,
    pub frame_crop_left_offset: u32,
    pub frame_crop_right_offset: u32,
    pub frame_crop_top_offset: u32,
    pub frame_crop_bottom_offset: u32,
    pub vui_parameters_present_flag: u8,
    pub vui_fields: _VAEncSequenceParameterBufferH264__bindgen_ty_2,
    pub aspect_ratio_idc: u8,
    pub sar_width: u32,
    pub sar_height: u32,
    pub num_units_in_tick: u32,
    pub time_scale: u32,
    pub va_reserved: [u32; 4usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _VAEncSequenceParameterBufferH264__bindgen_ty_1 {
    pub bits: _VAEncSequenceParameterBufferH264__bindgen_ty_1__bindgen_ty_1,
    pub value: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VAEncSequenceParameterBufferH264__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize]>,
    pub __bindgen_padding_0: u8,
}
impl _VAEncSequenceParameterBufferH264__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn chroma_format_idc(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_chroma_format_idc(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn frame_mbs_only_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_frame_mbs_only_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mb_adaptive_frame_field_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mb_adaptive_frame_field_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn seq_scaling_matrix_present_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_seq_scaling_matrix_present_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn direct_8x8_inference_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_direct_8x8_inference_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn log2_max_frame_num_minus4(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_log2_max_frame_num_minus4(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn pic_order_cnt_type(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_pic_order_cnt_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn log2_max_pic_order_cnt_lsb_minus4(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_log2_max_pic_order_cnt_lsb_minus4(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn delta_pic_order_always_zero_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_delta_pic_order_always_zero_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        chroma_format_idc: u32,
        frame_mbs_only_flag: u32,
        mb_adaptive_frame_field_flag: u32,
        seq_scaling_matrix_present_flag: u32,
        direct_8x8_inference_flag: u32,
        log2_max_frame_num_minus4: u32,
        pic_order_cnt_type: u32,
        log2_max_pic_order_cnt_lsb_minus4: u32,
        delta_pic_order_always_zero_flag: u32,
    ) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let chroma_format_idc: u32 = unsafe { ::std::mem::transmute(chroma_format_idc) };
            chroma_format_idc as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let frame_mbs_only_flag: u32 = unsafe { ::std::mem::transmute(frame_mbs_only_flag) };
            frame_mbs_only_flag as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let mb_adaptive_frame_field_flag: u32 =
                unsafe { ::std::mem::transmute(mb_adaptive_frame_field_flag) };
            mb_adaptive_frame_field_flag as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let seq_scaling_matrix_present_flag: u32 =
                unsafe { ::std::mem::transmute(seq_scaling_matrix_present_flag) };
            seq_scaling_matrix_present_flag as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let direct_8x8_inference_flag: u32 =
                unsafe { ::std::mem::transmute(direct_8x8_inference_flag) };
            direct_8x8_inference_flag as u64
        });
        __bindgen_bitfield_unit.set(6usize, 4u8, {
            let log2_max_frame_num_minus4: u32 =
                unsafe { ::std::mem::transmute(log2_max_frame_num_minus4) };
            log2_max_frame_num_minus4 as u64
        });
        __bindgen_bitfield_unit.set(10usize, 2u8, {
            let pic_order_cnt_type: u32 = unsafe { ::std::mem::transmute(pic_order_cnt_type) };
            pic_order_cnt_type as u64
        });
        __bindgen_bitfield_unit.set(12usize, 4u8, {
            let log2_max_pic_order_cnt_lsb_minus4: u32 =
                unsafe { ::std::mem::transmute(log2_max_pic_order_cnt_lsb_minus4) };
            log2_max_pic_order_cnt_lsb_minus4 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let delta_pic_order_always_zero_flag: u32 =
                unsafe { ::std::mem::transmute(delta_pic_order_always_zero_flag) };
            delta_pic_order_always_zero_flag as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _VAEncSequenceParameterBufferH264__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _VAEncSequenceParameterBufferH264__bindgen_ty_2 {
    pub bits: _VAEncSequenceParameterBufferH264__bindgen_ty_2__bindgen_ty_1,
    pub value: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VAEncSequenceParameterBufferH264__bindgen_ty_2__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _VAEncSequenceParameterBufferH264__bindgen_ty_2__bindgen_ty_1 {
    #[inline]
    pub fn aspect_ratio_info_present_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_aspect_ratio_info_present_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn timing_info_present_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_timing_info_present_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bitstream_restriction_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bitstream_restriction_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn log2_max_mv_length_horizontal(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_log2_max_mv_length_horizontal(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn log2_max_mv_length_vertical(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_log2_max_mv_length_vertical(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn fixed_frame_rate_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fixed_frame_rate_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn low_delay_hrd_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_low_delay_hrd_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn motion_vectors_over_pic_boundaries_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_motion_vectors_over_pic_boundaries_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        aspect_ratio_info_present_flag: u32,
        timing_info_present_flag: u32,
        bitstream_restriction_flag: u32,
        log2_max_mv_length_horizontal: u32,
        log2_max_mv_length_vertical: u32,
        fixed_frame_rate_flag: u32,
        low_delay_hrd_flag: u32,
        motion_vectors_over_pic_boundaries_flag: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let aspect_ratio_info_present_flag: u32 =
                unsafe { ::std::mem::transmute(aspect_ratio_info_present_flag) };
            aspect_ratio_info_present_flag as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let timing_info_present_flag: u32 =
                unsafe { ::std::mem::transmute(timing_info_present_flag) };
            timing_info_present_flag as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let bitstream_restriction_flag: u32 =
                unsafe { ::std::mem::transmute(bitstream_restriction_flag) };
            bitstream_restriction_flag as u64
        });
        __bindgen_bitfield_unit.set(3usize, 5u8, {
            let log2_max_mv_length_horizontal: u32 =
                unsafe { ::std::mem::transmute(log2_max_mv_length_horizontal) };
            log2_max_mv_length_horizontal as u64
        });
        __bindgen_bitfield_unit.set(8usize, 5u8, {
            let log2_max_mv_length_vertical: u32 =
                unsafe { ::std::mem::transmute(log2_max_mv_length_vertical) };
            log2_max_mv_length_vertical as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let fixed_frame_rate_flag: u32 =
                unsafe { ::std::mem::transmute(fixed_frame_rate_flag) };
            fixed_frame_rate_flag as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let low_delay_hrd_flag: u32 = unsafe { ::std::mem::transmute(low_delay_hrd_flag) };
            low_delay_hrd_flag as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let motion_vectors_over_pic_boundaries_flag: u32 =
                unsafe { ::std::mem::transmute(motion_vectors_over_pic_boundaries_flag) };
            motion_vectors_over_pic_boundaries_flag as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _VAEncSequenceParameterBufferH264__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _VAEncSequenceParameterBufferH264 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type VAEncSequenceParameterBufferH264 = _VAEncSequenceParameterBufferH264;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _VAEncPictureParameterBufferH264 {
    pub CurrPic: VAPictureH264,
    pub ReferenceFrames: [VAPictureH264; 16usize],
    pub coded_buf: VABufferID,
    pub pic_parameter_set_id: u8,
    pub seq_parameter_set_id: u8,
    pub last_picture: u8,
    pub frame_num: u16,
    pub pic_init_qp: u8,
    pub num_ref_idx_l0_active_minus1: u8,
    pub num_ref_idx_l1_active_minus1: u8,
    pub chroma_qp_index_offset: i8,
    pub second_chroma_qp_index_offset: i8,
    pub pic_fields: _VAEncPictureParameterBufferH264__bindgen_ty_1,
    pub va_reserved: [u32; 4usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _VAEncPictureParameterBufferH264__bindgen_ty_1 {
    pub bits: _VAEncPictureParameterBufferH264__bindgen_ty_1__bindgen_ty_1,
    pub value: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VAEncPictureParameterBufferH264__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub __bindgen_padding_0: u16,
}
impl _VAEncPictureParameterBufferH264__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn idr_pic_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_idr_pic_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reference_pic_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_reference_pic_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn entropy_coding_mode_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_entropy_coding_mode_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn weighted_pred_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_weighted_pred_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn weighted_bipred_idc(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_weighted_bipred_idc(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn constrained_intra_pred_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_constrained_intra_pred_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn transform_8x8_mode_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_transform_8x8_mode_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn deblocking_filter_control_present_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_deblocking_filter_control_present_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn redundant_pic_cnt_present_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_redundant_pic_cnt_present_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pic_order_present_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pic_order_present_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pic_scaling_matrix_present_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pic_scaling_matrix_present_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        idr_pic_flag: u32,
        reference_pic_flag: u32,
        entropy_coding_mode_flag: u32,
        weighted_pred_flag: u32,
        weighted_bipred_idc: u32,
        constrained_intra_pred_flag: u32,
        transform_8x8_mode_flag: u32,
        deblocking_filter_control_present_flag: u32,
        redundant_pic_cnt_present_flag: u32,
        pic_order_present_flag: u32,
        pic_scaling_matrix_present_flag: u32,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let idr_pic_flag: u32 = unsafe { ::std::mem::transmute(idr_pic_flag) };
            idr_pic_flag as u64
        });
        __bindgen_bitfield_unit.set(1usize, 2u8, {
            let reference_pic_flag: u32 = unsafe { ::std::mem::transmute(reference_pic_flag) };
            reference_pic_flag as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let entropy_coding_mode_flag: u32 =
                unsafe { ::std::mem::transmute(entropy_coding_mode_flag) };
            entropy_coding_mode_flag as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let weighted_pred_flag: u32 = unsafe { ::std::mem::transmute(weighted_pred_flag) };
            weighted_pred_flag as u64
        });
        __bindgen_bitfield_unit.set(5usize, 2u8, {
            let weighted_bipred_idc: u32 = unsafe { ::std::mem::transmute(weighted_bipred_idc) };
            weighted_bipred_idc as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let constrained_intra_pred_flag: u32 =
                unsafe { ::std::mem::transmute(constrained_intra_pred_flag) };
            constrained_intra_pred_flag as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let transform_8x8_mode_flag: u32 =
                unsafe { ::std::mem::transmute(transform_8x8_mode_flag) };
            transform_8x8_mode_flag as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let deblocking_filter_control_present_flag: u32 =
                unsafe { ::std::mem::transmute(deblocking_filter_control_present_flag) };
            deblocking_filter_control_present_flag as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let redundant_pic_cnt_present_flag: u32 =
                unsafe { ::std::mem::transmute(redundant_pic_cnt_present_flag) };
            redundant_pic_cnt_present_flag as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let pic_order_present_flag: u32 =
                unsafe { ::std::mem::transmute(pic_order_present_flag) };
            pic_order_present_flag as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let pic_scaling_matrix_present_flag: u32 =
                unsafe { ::std::mem::transmute(pic_scaling_matrix_present_flag) };
            pic_scaling_matrix_present_flag as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _VAEncPictureParameterBufferH264__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _VAEncPictureParameterBufferH264 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type VAEncPictureParameterBufferH264 = _VAEncPictureParameterBufferH264;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VAEncQPBufferH264 {
    pub qp: u8,
}
pub type VAEncQPBufferH264 = _VAEncQPBufferH264;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VAEncSliceParameterBufferH264 {
    pub macroblock_address: u32,
    pub num_macroblocks: u32,
    pub macroblock_info: VABufferID,
    pub slice_type: u8,
    pub pic_parameter_set_id: u8,
    pub idr_pic_id: u16,
    pub pic_order_cnt_lsb: u16,
    pub delta_pic_order_cnt_bottom: i32,
    pub delta_pic_order_cnt: [i32; 2usize],
    pub direct_spatial_mv_pred_flag: u8,
    pub num_ref_idx_active_override_flag: u8,
    pub num_ref_idx_l0_active_minus1: u8,
    pub num_ref_idx_l1_active_minus1: u8,
    pub RefPicList0: [VAPictureH264; 32usize],
    pub RefPicList1: [VAPictureH264; 32usize],
    pub luma_log2_weight_denom: u8,
    pub chroma_log2_weight_denom: u8,
    pub luma_weight_l0_flag: u8,
    pub luma_weight_l0: [::std::os::raw::c_short; 32usize],
    pub luma_offset_l0: [::std::os::raw::c_short; 32usize],
    pub chroma_weight_l0_flag: u8,
    pub chroma_weight_l0: [[::std::os::raw::c_short; 2usize]; 32usize],
    pub chroma_offset_l0: [[::std::os::raw::c_short; 2usize]; 32usize],
    pub luma_weight_l1_flag: u8,
    pub luma_weight_l1: [::std::os::raw::c_short; 32usize],
    pub luma_offset_l1: [::std::os::raw::c_short; 32usize],
    pub chroma_weight_l1_flag: u8,
    pub chroma_weight_l1: [[::std::os::raw::c_short; 2usize]; 32usize],
    pub chroma_offset_l1: [[::std::os::raw::c_short; 2usize]; 32usize],
    pub cabac_init_idc: u8,
    pub slice_qp_delta: i8,
    pub disable_deblocking_filter_idc: u8,
    pub slice_alpha_c0_offset_div2: i8,
    pub slice_beta_offset_div2: i8,
    pub va_reserved: [u32; 4usize],
}
pub type VAEncSliceParameterBufferH264 = _VAEncSliceParameterBufferH264;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _VAEncMacroblockParameterBufferH264 {
    pub qp: u8,
    pub info: _VAEncMacroblockParameterBufferH264__bindgen_ty_1,
    pub va_reserved: [u32; 4usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _VAEncMacroblockParameterBufferH264__bindgen_ty_1 {
    pub intra_fields: _VAEncMacroblockParameterBufferH264__bindgen_ty_1__bindgen_ty_1,
    pub inter_fields: _VAEncMacroblockParameterBufferH264__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _VAEncMacroblockParameterBufferH264__bindgen_ty_1__bindgen_ty_1 {
    pub bits: _VAEncMacroblockParameterBufferH264__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    pub value: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VAEncMacroblockParameterBufferH264__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub __bindgen_padding_0: u16,
}
impl _VAEncMacroblockParameterBufferH264__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn pred_avail_override_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pred_avail_override_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pred_avail_flags(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_pred_avail_flags(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        pred_avail_override_flag: u32,
        pred_avail_flags: u32,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let pred_avail_override_flag: u32 =
                unsafe { ::std::mem::transmute(pred_avail_override_flag) };
            pred_avail_override_flag as u64
        });
        __bindgen_bitfield_unit.set(1usize, 8u8, {
            let pred_avail_flags: u32 = unsafe { ::std::mem::transmute(pred_avail_flags) };
            pred_avail_flags as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _VAEncMacroblockParameterBufferH264__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _VAEncMacroblockParameterBufferH264__bindgen_ty_1__bindgen_ty_2 {
    pub bits: _VAEncMacroblockParameterBufferH264__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1,
    pub value: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VAEncMacroblockParameterBufferH264__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 {
    pub reserved: u32,
}
impl Default for _VAEncMacroblockParameterBufferH264__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _VAEncMacroblockParameterBufferH264__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _VAEncMacroblockParameterBufferH264 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type VAEncMacroblockParameterBufferH264 = _VAEncMacroblockParameterBufferH264;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _VAEncMiscParameterSubMbPartPelH264 {
    pub disable_inter_sub_mb_partition: u32,
    pub inter_sub_mb_partition_mask: _VAEncMiscParameterSubMbPartPelH264__bindgen_ty_1,
    pub enable_sub_pel_mode: u32,
    pub sub_pel_mode: u8,
    pub reserved: [u8; 3usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _VAEncMiscParameterSubMbPartPelH264__bindgen_ty_1 {
    pub bits: _VAEncMiscParameterSubMbPartPelH264__bindgen_ty_1__bindgen_ty_1,
    pub value: u8,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VAEncMiscParameterSubMbPartPelH264__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl _VAEncMiscParameterSubMbPartPelH264__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn disable_16x16_inter_mb_partition(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disable_16x16_inter_mb_partition(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn disable_16x8_inter_mb_partition(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disable_16x8_inter_mb_partition(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn disable_8x16_inter_mb_partition(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disable_8x16_inter_mb_partition(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn disable_8x8_inter_mb_partition(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disable_8x8_inter_mb_partition(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn disable_8x4_inter_mb_partition(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disable_8x4_inter_mb_partition(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn disable_4x8_inter_mb_partition(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disable_4x8_inter_mb_partition(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn disable_4x4_inter_mb_partition(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disable_4x4_inter_mb_partition(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        disable_16x16_inter_mb_partition: u32,
        disable_16x8_inter_mb_partition: u32,
        disable_8x16_inter_mb_partition: u32,
        disable_8x8_inter_mb_partition: u32,
        disable_8x4_inter_mb_partition: u32,
        disable_4x8_inter_mb_partition: u32,
        disable_4x4_inter_mb_partition: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let disable_16x16_inter_mb_partition: u32 =
                unsafe { ::std::mem::transmute(disable_16x16_inter_mb_partition) };
            disable_16x16_inter_mb_partition as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let disable_16x8_inter_mb_partition: u32 =
                unsafe { ::std::mem::transmute(disable_16x8_inter_mb_partition) };
            disable_16x8_inter_mb_partition as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let disable_8x16_inter_mb_partition: u32 =
                unsafe { ::std::mem::transmute(disable_8x16_inter_mb_partition) };
            disable_8x16_inter_mb_partition as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let disable_8x8_inter_mb_partition: u32 =
                unsafe { ::std::mem::transmute(disable_8x8_inter_mb_partition) };
            disable_8x8_inter_mb_partition as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let disable_8x4_inter_mb_partition: u32 =
                unsafe { ::std::mem::transmute(disable_8x4_inter_mb_partition) };
            disable_8x4_inter_mb_partition as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let disable_4x8_inter_mb_partition: u32 =
                unsafe { ::std::mem::transmute(disable_4x8_inter_mb_partition) };
            disable_4x8_inter_mb_partition as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let disable_4x4_inter_mb_partition: u32 =
                unsafe { ::std::mem::transmute(disable_4x4_inter_mb_partition) };
            disable_4x4_inter_mb_partition as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _VAEncMiscParameterSubMbPartPelH264__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _VAEncMiscParameterSubMbPartPelH264 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type VAEncMiscParameterSubMbPartPelH264 = _VAEncMiscParameterSubMbPartPelH264;
pub type VAQMatrixBufferMPEG2 = VAIQMatrixBufferMPEG2;
pub mod VAEncPackedHeaderTypeMPEG2 {
    pub type Type = ::std::os::raw::c_uint;
    pub const VAEncPackedHeaderMPEG2_SPS: Type = 1;
    pub const VAEncPackedHeaderMPEG2_PPS: Type = 2;
    pub const VAEncPackedHeaderMPEG2_Slice: Type = 3;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _VAEncSequenceParameterBufferMPEG2 {
    pub intra_period: u32,
    pub ip_period: u32,
    pub picture_width: u16,
    pub picture_height: u16,
    pub bits_per_second: u32,
    pub frame_rate: f32,
    pub aspect_ratio_information: u16,
    pub vbv_buffer_size: u32,
    pub sequence_extension: _VAEncSequenceParameterBufferMPEG2__bindgen_ty_1,
    pub new_gop_header: u32,
    pub gop_header: _VAEncSequenceParameterBufferMPEG2__bindgen_ty_2,
    pub va_reserved: [u32; 4usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _VAEncSequenceParameterBufferMPEG2__bindgen_ty_1 {
    pub bits: _VAEncSequenceParameterBufferMPEG2__bindgen_ty_1__bindgen_ty_1,
    pub value: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VAEncSequenceParameterBufferMPEG2__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize]>,
    pub __bindgen_padding_0: u8,
}
impl _VAEncSequenceParameterBufferMPEG2__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn profile_and_level_indication(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_profile_and_level_indication(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn progressive_sequence(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_progressive_sequence(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn chroma_format(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_chroma_format(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn low_delay(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_low_delay(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn frame_rate_extension_n(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_frame_rate_extension_n(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn frame_rate_extension_d(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_frame_rate_extension_d(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        profile_and_level_indication: u32,
        progressive_sequence: u32,
        chroma_format: u32,
        low_delay: u32,
        frame_rate_extension_n: u32,
        frame_rate_extension_d: u32,
    ) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let profile_and_level_indication: u32 =
                unsafe { ::std::mem::transmute(profile_and_level_indication) };
            profile_and_level_indication as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let progressive_sequence: u32 = unsafe { ::std::mem::transmute(progressive_sequence) };
            progressive_sequence as u64
        });
        __bindgen_bitfield_unit.set(9usize, 2u8, {
            let chroma_format: u32 = unsafe { ::std::mem::transmute(chroma_format) };
            chroma_format as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let low_delay: u32 = unsafe { ::std::mem::transmute(low_delay) };
            low_delay as u64
        });
        __bindgen_bitfield_unit.set(12usize, 2u8, {
            let frame_rate_extension_n: u32 =
                unsafe { ::std::mem::transmute(frame_rate_extension_n) };
            frame_rate_extension_n as u64
        });
        __bindgen_bitfield_unit.set(14usize, 5u8, {
            let frame_rate_extension_d: u32 =
                unsafe { ::std::mem::transmute(frame_rate_extension_d) };
            frame_rate_extension_d as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _VAEncSequenceParameterBufferMPEG2__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _VAEncSequenceParameterBufferMPEG2__bindgen_ty_2 {
    pub bits: _VAEncSequenceParameterBufferMPEG2__bindgen_ty_2__bindgen_ty_1,
    pub value: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VAEncSequenceParameterBufferMPEG2__bindgen_ty_2__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _VAEncSequenceParameterBufferMPEG2__bindgen_ty_2__bindgen_ty_1 {
    #[inline]
    pub fn time_code(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 25u8) as u32) }
    }
    #[inline]
    pub fn set_time_code(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 25u8, val as u64)
        }
    }
    #[inline]
    pub fn closed_gop(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_closed_gop(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn broken_link(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_broken_link(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        time_code: u32,
        closed_gop: u32,
        broken_link: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 25u8, {
            let time_code: u32 = unsafe { ::std::mem::transmute(time_code) };
            time_code as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let closed_gop: u32 = unsafe { ::std::mem::transmute(closed_gop) };
            closed_gop as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let broken_link: u32 = unsafe { ::std::mem::transmute(broken_link) };
            broken_link as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _VAEncSequenceParameterBufferMPEG2__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _VAEncSequenceParameterBufferMPEG2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type VAEncSequenceParameterBufferMPEG2 = _VAEncSequenceParameterBufferMPEG2;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _VAEncPictureParameterBufferMPEG2 {
    pub forward_reference_picture: VASurfaceID,
    pub backward_reference_picture: VASurfaceID,
    pub reconstructed_picture: VASurfaceID,
    pub coded_buf: VABufferID,
    pub last_picture: u8,
    pub picture_type: VAEncPictureType::Type,
    pub temporal_reference: u32,
    pub vbv_delay: u32,
    pub f_code: [[u8; 2usize]; 2usize],
    pub picture_coding_extension: _VAEncPictureParameterBufferMPEG2__bindgen_ty_1,
    pub composite_display: _VAEncPictureParameterBufferMPEG2__bindgen_ty_2,
    pub va_reserved: [u32; 4usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _VAEncPictureParameterBufferMPEG2__bindgen_ty_1 {
    pub bits: _VAEncPictureParameterBufferMPEG2__bindgen_ty_1__bindgen_ty_1,
    pub value: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VAEncPictureParameterBufferMPEG2__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub __bindgen_padding_0: u16,
}
impl _VAEncPictureParameterBufferMPEG2__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn intra_dc_precision(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_intra_dc_precision(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn picture_structure(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_picture_structure(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn top_field_first(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_top_field_first(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn frame_pred_frame_dct(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_frame_pred_frame_dct(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn concealment_motion_vectors(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_concealment_motion_vectors(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn q_scale_type(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_q_scale_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn intra_vlc_format(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_intra_vlc_format(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn alternate_scan(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_alternate_scan(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn repeat_first_field(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_repeat_first_field(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn progressive_frame(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_progressive_frame(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn composite_display_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_composite_display_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        intra_dc_precision: u32,
        picture_structure: u32,
        top_field_first: u32,
        frame_pred_frame_dct: u32,
        concealment_motion_vectors: u32,
        q_scale_type: u32,
        intra_vlc_format: u32,
        alternate_scan: u32,
        repeat_first_field: u32,
        progressive_frame: u32,
        composite_display_flag: u32,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let intra_dc_precision: u32 = unsafe { ::std::mem::transmute(intra_dc_precision) };
            intra_dc_precision as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let picture_structure: u32 = unsafe { ::std::mem::transmute(picture_structure) };
            picture_structure as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let top_field_first: u32 = unsafe { ::std::mem::transmute(top_field_first) };
            top_field_first as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let frame_pred_frame_dct: u32 = unsafe { ::std::mem::transmute(frame_pred_frame_dct) };
            frame_pred_frame_dct as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let concealment_motion_vectors: u32 =
                unsafe { ::std::mem::transmute(concealment_motion_vectors) };
            concealment_motion_vectors as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let q_scale_type: u32 = unsafe { ::std::mem::transmute(q_scale_type) };
            q_scale_type as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let intra_vlc_format: u32 = unsafe { ::std::mem::transmute(intra_vlc_format) };
            intra_vlc_format as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let alternate_scan: u32 = unsafe { ::std::mem::transmute(alternate_scan) };
            alternate_scan as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let repeat_first_field: u32 = unsafe { ::std::mem::transmute(repeat_first_field) };
            repeat_first_field as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let progressive_frame: u32 = unsafe { ::std::mem::transmute(progressive_frame) };
            progressive_frame as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let composite_display_flag: u32 =
                unsafe { ::std::mem::transmute(composite_display_flag) };
            composite_display_flag as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _VAEncPictureParameterBufferMPEG2__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _VAEncPictureParameterBufferMPEG2__bindgen_ty_2 {
    pub bits: _VAEncPictureParameterBufferMPEG2__bindgen_ty_2__bindgen_ty_1,
    pub value: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VAEncPictureParameterBufferMPEG2__bindgen_ty_2__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize]>,
    pub __bindgen_padding_0: u8,
}
impl _VAEncPictureParameterBufferMPEG2__bindgen_ty_2__bindgen_ty_1 {
    #[inline]
    pub fn v_axis(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_v_axis(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn field_sequence(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_field_sequence(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn sub_carrier(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sub_carrier(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn burst_amplitude(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_burst_amplitude(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn sub_carrier_phase(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_sub_carrier_phase(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        v_axis: u32,
        field_sequence: u32,
        sub_carrier: u32,
        burst_amplitude: u32,
        sub_carrier_phase: u32,
    ) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let v_axis: u32 = unsafe { ::std::mem::transmute(v_axis) };
            v_axis as u64
        });
        __bindgen_bitfield_unit.set(1usize, 3u8, {
            let field_sequence: u32 = unsafe { ::std::mem::transmute(field_sequence) };
            field_sequence as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let sub_carrier: u32 = unsafe { ::std::mem::transmute(sub_carrier) };
            sub_carrier as u64
        });
        __bindgen_bitfield_unit.set(5usize, 7u8, {
            let burst_amplitude: u32 = unsafe { ::std::mem::transmute(burst_amplitude) };
            burst_amplitude as u64
        });
        __bindgen_bitfield_unit.set(12usize, 8u8, {
            let sub_carrier_phase: u32 = unsafe { ::std::mem::transmute(sub_carrier_phase) };
            sub_carrier_phase as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _VAEncPictureParameterBufferMPEG2__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _VAEncPictureParameterBufferMPEG2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type VAEncPictureParameterBufferMPEG2 = _VAEncPictureParameterBufferMPEG2;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VAEncSliceParameterBufferMPEG2 {
    pub macroblock_address: u32,
    pub num_macroblocks: u32,
    pub quantiser_scale_code: i32,
    pub is_intra_slice: i32,
    pub va_reserved: [u32; 4usize],
}
pub type VAEncSliceParameterBufferMPEG2 = _VAEncSliceParameterBufferMPEG2;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VAEncMiscParameterExtensionDataSeqDisplayMPEG2 {
    pub extension_start_code_identifier: u8,
    pub video_format: u8,
    pub colour_description: u8,
    pub colour_primaries: u8,
    pub transfer_characteristics: u8,
    pub matrix_coefficients: u8,
    pub display_horizontal_size: u16,
    pub display_vertical_size: u16,
}
pub type VAEncMiscParameterExtensionDataSeqDisplayMPEG2 =
    _VAEncMiscParameterExtensionDataSeqDisplayMPEG2;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VAEncSequenceParameterBufferVP8 {
    pub frame_width: u32,
    pub frame_height: u32,
    pub frame_width_scale: u32,
    pub frame_height_scale: u32,
    pub error_resilient: u32,
    pub kf_auto: u32,
    pub kf_min_dist: u32,
    pub kf_max_dist: u32,
    pub bits_per_second: u32,
    pub intra_period: u32,
    pub reference_frames: [VASurfaceID; 4usize],
    pub va_reserved: [u32; 4usize],
}
pub type VAEncSequenceParameterBufferVP8 = _VAEncSequenceParameterBufferVP8;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _VAEncPictureParameterBufferVP8 {
    pub reconstructed_frame: VASurfaceID,
    pub ref_last_frame: VASurfaceID,
    pub ref_gf_frame: VASurfaceID,
    pub ref_arf_frame: VASurfaceID,
    pub coded_buf: VABufferID,
    pub ref_flags: _VAEncPictureParameterBufferVP8__bindgen_ty_1,
    pub pic_flags: _VAEncPictureParameterBufferVP8__bindgen_ty_2,
    pub loop_filter_level: [i8; 4usize],
    pub ref_lf_delta: [i8; 4usize],
    pub mode_lf_delta: [i8; 4usize],
    pub sharpness_level: u8,
    pub clamp_qindex_high: u8,
    pub clamp_qindex_low: u8,
    pub va_reserved: [u32; 4usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _VAEncPictureParameterBufferVP8__bindgen_ty_1 {
    pub bits: _VAEncPictureParameterBufferVP8__bindgen_ty_1__bindgen_ty_1,
    pub value: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VAEncPictureParameterBufferVP8__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _VAEncPictureParameterBufferVP8__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn force_kf(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_force_kf(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn no_ref_last(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_no_ref_last(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn no_ref_gf(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_no_ref_gf(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn no_ref_arf(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_no_ref_arf(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn temporal_id(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_temporal_id(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn first_ref(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_first_ref(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn second_ref(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_second_ref(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        force_kf: u32,
        no_ref_last: u32,
        no_ref_gf: u32,
        no_ref_arf: u32,
        temporal_id: u32,
        first_ref: u32,
        second_ref: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let force_kf: u32 = unsafe { ::std::mem::transmute(force_kf) };
            force_kf as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let no_ref_last: u32 = unsafe { ::std::mem::transmute(no_ref_last) };
            no_ref_last as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let no_ref_gf: u32 = unsafe { ::std::mem::transmute(no_ref_gf) };
            no_ref_gf as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let no_ref_arf: u32 = unsafe { ::std::mem::transmute(no_ref_arf) };
            no_ref_arf as u64
        });
        __bindgen_bitfield_unit.set(4usize, 8u8, {
            let temporal_id: u32 = unsafe { ::std::mem::transmute(temporal_id) };
            temporal_id as u64
        });
        __bindgen_bitfield_unit.set(12usize, 2u8, {
            let first_ref: u32 = unsafe { ::std::mem::transmute(first_ref) };
            first_ref as u64
        });
        __bindgen_bitfield_unit.set(14usize, 2u8, {
            let second_ref: u32 = unsafe { ::std::mem::transmute(second_ref) };
            second_ref as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _VAEncPictureParameterBufferVP8__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _VAEncPictureParameterBufferVP8__bindgen_ty_2 {
    pub bits: _VAEncPictureParameterBufferVP8__bindgen_ty_2__bindgen_ty_1,
    pub value: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VAEncPictureParameterBufferVP8__bindgen_ty_2__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _VAEncPictureParameterBufferVP8__bindgen_ty_2__bindgen_ty_1 {
    #[inline]
    pub fn frame_type(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_frame_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn version(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_version(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn show_frame(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_show_frame(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn color_space(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_color_space(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn recon_filter_type(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_recon_filter_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn loop_filter_type(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_loop_filter_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn auto_partitions(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_auto_partitions(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn num_token_partitions(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_num_token_partitions(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn clamping_type(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_clamping_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn segmentation_enabled(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_segmentation_enabled(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn update_mb_segmentation_map(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_update_mb_segmentation_map(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn update_segment_feature_data(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_update_segment_feature_data(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn loop_filter_adj_enable(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_loop_filter_adj_enable(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn refresh_entropy_probs(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_refresh_entropy_probs(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn refresh_golden_frame(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_refresh_golden_frame(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn refresh_alternate_frame(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_refresh_alternate_frame(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn refresh_last(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_refresh_last(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn copy_buffer_to_golden(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(22usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_copy_buffer_to_golden(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(22usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn copy_buffer_to_alternate(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_copy_buffer_to_alternate(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn sign_bias_golden(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sign_bias_golden(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sign_bias_alternate(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sign_bias_alternate(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mb_no_coeff_skip(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mb_no_coeff_skip(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn forced_lf_adjustment(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_forced_lf_adjustment(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(30usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(30usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        frame_type: u32,
        version: u32,
        show_frame: u32,
        color_space: u32,
        recon_filter_type: u32,
        loop_filter_type: u32,
        auto_partitions: u32,
        num_token_partitions: u32,
        clamping_type: u32,
        segmentation_enabled: u32,
        update_mb_segmentation_map: u32,
        update_segment_feature_data: u32,
        loop_filter_adj_enable: u32,
        refresh_entropy_probs: u32,
        refresh_golden_frame: u32,
        refresh_alternate_frame: u32,
        refresh_last: u32,
        copy_buffer_to_golden: u32,
        copy_buffer_to_alternate: u32,
        sign_bias_golden: u32,
        sign_bias_alternate: u32,
        mb_no_coeff_skip: u32,
        forced_lf_adjustment: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let frame_type: u32 = unsafe { ::std::mem::transmute(frame_type) };
            frame_type as u64
        });
        __bindgen_bitfield_unit.set(1usize, 3u8, {
            let version: u32 = unsafe { ::std::mem::transmute(version) };
            version as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let show_frame: u32 = unsafe { ::std::mem::transmute(show_frame) };
            show_frame as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let color_space: u32 = unsafe { ::std::mem::transmute(color_space) };
            color_space as u64
        });
        __bindgen_bitfield_unit.set(6usize, 2u8, {
            let recon_filter_type: u32 = unsafe { ::std::mem::transmute(recon_filter_type) };
            recon_filter_type as u64
        });
        __bindgen_bitfield_unit.set(8usize, 2u8, {
            let loop_filter_type: u32 = unsafe { ::std::mem::transmute(loop_filter_type) };
            loop_filter_type as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let auto_partitions: u32 = unsafe { ::std::mem::transmute(auto_partitions) };
            auto_partitions as u64
        });
        __bindgen_bitfield_unit.set(11usize, 2u8, {
            let num_token_partitions: u32 = unsafe { ::std::mem::transmute(num_token_partitions) };
            num_token_partitions as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let clamping_type: u32 = unsafe { ::std::mem::transmute(clamping_type) };
            clamping_type as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let segmentation_enabled: u32 = unsafe { ::std::mem::transmute(segmentation_enabled) };
            segmentation_enabled as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let update_mb_segmentation_map: u32 =
                unsafe { ::std::mem::transmute(update_mb_segmentation_map) };
            update_mb_segmentation_map as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let update_segment_feature_data: u32 =
                unsafe { ::std::mem::transmute(update_segment_feature_data) };
            update_segment_feature_data as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let loop_filter_adj_enable: u32 =
                unsafe { ::std::mem::transmute(loop_filter_adj_enable) };
            loop_filter_adj_enable as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let refresh_entropy_probs: u32 =
                unsafe { ::std::mem::transmute(refresh_entropy_probs) };
            refresh_entropy_probs as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let refresh_golden_frame: u32 = unsafe { ::std::mem::transmute(refresh_golden_frame) };
            refresh_golden_frame as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let refresh_alternate_frame: u32 =
                unsafe { ::std::mem::transmute(refresh_alternate_frame) };
            refresh_alternate_frame as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let refresh_last: u32 = unsafe { ::std::mem::transmute(refresh_last) };
            refresh_last as u64
        });
        __bindgen_bitfield_unit.set(22usize, 2u8, {
            let copy_buffer_to_golden: u32 =
                unsafe { ::std::mem::transmute(copy_buffer_to_golden) };
            copy_buffer_to_golden as u64
        });
        __bindgen_bitfield_unit.set(24usize, 2u8, {
            let copy_buffer_to_alternate: u32 =
                unsafe { ::std::mem::transmute(copy_buffer_to_alternate) };
            copy_buffer_to_alternate as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let sign_bias_golden: u32 = unsafe { ::std::mem::transmute(sign_bias_golden) };
            sign_bias_golden as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let sign_bias_alternate: u32 = unsafe { ::std::mem::transmute(sign_bias_alternate) };
            sign_bias_alternate as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let mb_no_coeff_skip: u32 = unsafe { ::std::mem::transmute(mb_no_coeff_skip) };
            mb_no_coeff_skip as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let forced_lf_adjustment: u32 = unsafe { ::std::mem::transmute(forced_lf_adjustment) };
            forced_lf_adjustment as u64
        });
        __bindgen_bitfield_unit.set(30usize, 2u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _VAEncPictureParameterBufferVP8__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _VAEncPictureParameterBufferVP8 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type VAEncPictureParameterBufferVP8 = _VAEncPictureParameterBufferVP8;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _VAEncMBMapBufferVP8 {
    pub num_mbs: u32,
    pub mb_segment_id: *mut u8,
    pub va_reserved: [u32; 4usize],
}
impl Default for _VAEncMBMapBufferVP8 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type VAEncMBMapBufferVP8 = _VAEncMBMapBufferVP8;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VAQMatrixBufferVP8 {
    pub quantization_index: [u16; 4usize],
    pub quantization_index_delta: [i16; 5usize],
    pub va_reserved: [u32; 4usize],
}
pub type VAQMatrixBufferVP8 = _VAQMatrixBufferVP8;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VACodedBufferVP9Status {
    pub base_qp_index: u16,
    pub loop_filter_level: u8,
    pub long_term_indication: u8,
    pub next_frame_width: u16,
    pub next_frame_height: u16,
    pub va_reserved: [u32; 4usize],
}
pub type VACodedBufferVP9Status = _VACodedBufferVP9Status;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VAEncSequenceParameterBufferVP9 {
    pub max_frame_width: u32,
    pub max_frame_height: u32,
    pub kf_auto: u32,
    pub kf_min_dist: u32,
    pub kf_max_dist: u32,
    pub bits_per_second: u32,
    pub intra_period: u32,
    pub va_reserved: [u32; 4usize],
}
pub type VAEncSequenceParameterBufferVP9 = _VAEncSequenceParameterBufferVP9;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _VAEncPictureParameterBufferVP9 {
    pub frame_width_src: u32,
    pub frame_height_src: u32,
    pub frame_width_dst: u32,
    pub frame_height_dst: u32,
    pub reconstructed_frame: VASurfaceID,
    pub reference_frames: [VASurfaceID; 8usize],
    pub coded_buf: VABufferID,
    pub ref_flags: _VAEncPictureParameterBufferVP9__bindgen_ty_1,
    pub pic_flags: _VAEncPictureParameterBufferVP9__bindgen_ty_2,
    pub refresh_frame_flags: u8,
    pub luma_ac_qindex: u8,
    pub luma_dc_qindex_delta: i8,
    pub chroma_ac_qindex_delta: i8,
    pub chroma_dc_qindex_delta: i8,
    pub filter_level: u8,
    pub sharpness_level: u8,
    pub ref_lf_delta: [i8; 4usize],
    pub mode_lf_delta: [i8; 2usize],
    pub bit_offset_ref_lf_delta: u16,
    pub bit_offset_mode_lf_delta: u16,
    pub bit_offset_lf_level: u16,
    pub bit_offset_qindex: u16,
    pub bit_offset_first_partition_size: u16,
    pub bit_offset_segmentation: u16,
    pub bit_size_segmentation: u16,
    pub log2_tile_rows: u8,
    pub log2_tile_columns: u8,
    pub skip_frame_flag: u8,
    pub number_skip_frames: u8,
    pub skip_frames_size: u32,
    pub va_reserved: [u32; 8usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _VAEncPictureParameterBufferVP9__bindgen_ty_1 {
    pub bits: _VAEncPictureParameterBufferVP9__bindgen_ty_1__bindgen_ty_1,
    pub value: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VAEncPictureParameterBufferVP9__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _VAEncPictureParameterBufferVP9__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn force_kf(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_force_kf(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ref_frame_ctrl_l0(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_ref_frame_ctrl_l0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn ref_frame_ctrl_l1(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_ref_frame_ctrl_l1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn ref_last_idx(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_ref_last_idx(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn ref_last_sign_bias(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ref_last_sign_bias(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ref_gf_idx(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_ref_gf_idx(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn ref_gf_sign_bias(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ref_gf_sign_bias(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ref_arf_idx(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_ref_arf_idx(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn ref_arf_sign_bias(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ref_arf_sign_bias(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn temporal_id(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_temporal_id(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(27usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(27usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        force_kf: u32,
        ref_frame_ctrl_l0: u32,
        ref_frame_ctrl_l1: u32,
        ref_last_idx: u32,
        ref_last_sign_bias: u32,
        ref_gf_idx: u32,
        ref_gf_sign_bias: u32,
        ref_arf_idx: u32,
        ref_arf_sign_bias: u32,
        temporal_id: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let force_kf: u32 = unsafe { ::std::mem::transmute(force_kf) };
            force_kf as u64
        });
        __bindgen_bitfield_unit.set(1usize, 3u8, {
            let ref_frame_ctrl_l0: u32 = unsafe { ::std::mem::transmute(ref_frame_ctrl_l0) };
            ref_frame_ctrl_l0 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 3u8, {
            let ref_frame_ctrl_l1: u32 = unsafe { ::std::mem::transmute(ref_frame_ctrl_l1) };
            ref_frame_ctrl_l1 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 3u8, {
            let ref_last_idx: u32 = unsafe { ::std::mem::transmute(ref_last_idx) };
            ref_last_idx as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let ref_last_sign_bias: u32 = unsafe { ::std::mem::transmute(ref_last_sign_bias) };
            ref_last_sign_bias as u64
        });
        __bindgen_bitfield_unit.set(11usize, 3u8, {
            let ref_gf_idx: u32 = unsafe { ::std::mem::transmute(ref_gf_idx) };
            ref_gf_idx as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let ref_gf_sign_bias: u32 = unsafe { ::std::mem::transmute(ref_gf_sign_bias) };
            ref_gf_sign_bias as u64
        });
        __bindgen_bitfield_unit.set(15usize, 3u8, {
            let ref_arf_idx: u32 = unsafe { ::std::mem::transmute(ref_arf_idx) };
            ref_arf_idx as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let ref_arf_sign_bias: u32 = unsafe { ::std::mem::transmute(ref_arf_sign_bias) };
            ref_arf_sign_bias as u64
        });
        __bindgen_bitfield_unit.set(19usize, 8u8, {
            let temporal_id: u32 = unsafe { ::std::mem::transmute(temporal_id) };
            temporal_id as u64
        });
        __bindgen_bitfield_unit.set(27usize, 5u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _VAEncPictureParameterBufferVP9__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _VAEncPictureParameterBufferVP9__bindgen_ty_2 {
    pub bits: _VAEncPictureParameterBufferVP9__bindgen_ty_2__bindgen_ty_1,
    pub value: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VAEncPictureParameterBufferVP9__bindgen_ty_2__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _VAEncPictureParameterBufferVP9__bindgen_ty_2__bindgen_ty_1 {
    #[inline]
    pub fn frame_type(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_frame_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn show_frame(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_show_frame(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn error_resilient_mode(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_error_resilient_mode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn intra_only(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_intra_only(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn allow_high_precision_mv(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_allow_high_precision_mv(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mcomp_filter_type(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_mcomp_filter_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn frame_parallel_decoding_mode(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_frame_parallel_decoding_mode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reset_frame_context(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_reset_frame_context(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn refresh_frame_context(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_refresh_frame_context(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn frame_context_idx(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_frame_context_idx(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn segmentation_enabled(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_segmentation_enabled(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn segmentation_temporal_update(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_segmentation_temporal_update(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn segmentation_update_map(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_segmentation_update_map(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn lossless_mode(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_lossless_mode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn comp_prediction_mode(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_comp_prediction_mode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn auto_segmentation(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_auto_segmentation(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn super_frame_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_super_frame_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(22usize, 10u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(22usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        frame_type: u32,
        show_frame: u32,
        error_resilient_mode: u32,
        intra_only: u32,
        allow_high_precision_mv: u32,
        mcomp_filter_type: u32,
        frame_parallel_decoding_mode: u32,
        reset_frame_context: u32,
        refresh_frame_context: u32,
        frame_context_idx: u32,
        segmentation_enabled: u32,
        segmentation_temporal_update: u32,
        segmentation_update_map: u32,
        lossless_mode: u32,
        comp_prediction_mode: u32,
        auto_segmentation: u32,
        super_frame_flag: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let frame_type: u32 = unsafe { ::std::mem::transmute(frame_type) };
            frame_type as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let show_frame: u32 = unsafe { ::std::mem::transmute(show_frame) };
            show_frame as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let error_resilient_mode: u32 = unsafe { ::std::mem::transmute(error_resilient_mode) };
            error_resilient_mode as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let intra_only: u32 = unsafe { ::std::mem::transmute(intra_only) };
            intra_only as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let allow_high_precision_mv: u32 =
                unsafe { ::std::mem::transmute(allow_high_precision_mv) };
            allow_high_precision_mv as u64
        });
        __bindgen_bitfield_unit.set(5usize, 3u8, {
            let mcomp_filter_type: u32 = unsafe { ::std::mem::transmute(mcomp_filter_type) };
            mcomp_filter_type as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let frame_parallel_decoding_mode: u32 =
                unsafe { ::std::mem::transmute(frame_parallel_decoding_mode) };
            frame_parallel_decoding_mode as u64
        });
        __bindgen_bitfield_unit.set(9usize, 2u8, {
            let reset_frame_context: u32 = unsafe { ::std::mem::transmute(reset_frame_context) };
            reset_frame_context as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let refresh_frame_context: u32 =
                unsafe { ::std::mem::transmute(refresh_frame_context) };
            refresh_frame_context as u64
        });
        __bindgen_bitfield_unit.set(12usize, 2u8, {
            let frame_context_idx: u32 = unsafe { ::std::mem::transmute(frame_context_idx) };
            frame_context_idx as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let segmentation_enabled: u32 = unsafe { ::std::mem::transmute(segmentation_enabled) };
            segmentation_enabled as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let segmentation_temporal_update: u32 =
                unsafe { ::std::mem::transmute(segmentation_temporal_update) };
            segmentation_temporal_update as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let segmentation_update_map: u32 =
                unsafe { ::std::mem::transmute(segmentation_update_map) };
            segmentation_update_map as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let lossless_mode: u32 = unsafe { ::std::mem::transmute(lossless_mode) };
            lossless_mode as u64
        });
        __bindgen_bitfield_unit.set(18usize, 2u8, {
            let comp_prediction_mode: u32 = unsafe { ::std::mem::transmute(comp_prediction_mode) };
            comp_prediction_mode as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let auto_segmentation: u32 = unsafe { ::std::mem::transmute(auto_segmentation) };
            auto_segmentation as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let super_frame_flag: u32 = unsafe { ::std::mem::transmute(super_frame_flag) };
            super_frame_flag as u64
        });
        __bindgen_bitfield_unit.set(22usize, 10u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _VAEncPictureParameterBufferVP9__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _VAEncPictureParameterBufferVP9 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type VAEncPictureParameterBufferVP9 = _VAEncPictureParameterBufferVP9;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _VAEncSegParamVP9 {
    pub seg_flags: _VAEncSegParamVP9__bindgen_ty_1,
    pub segment_lf_level_delta: i8,
    pub segment_qindex_delta: i16,
    pub va_reserved: [u32; 4usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _VAEncSegParamVP9__bindgen_ty_1 {
    pub bits: _VAEncSegParamVP9__bindgen_ty_1__bindgen_ty_1,
    pub value: u8,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VAEncSegParamVP9__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl _VAEncSegParamVP9__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn segment_reference_enabled(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_segment_reference_enabled(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn segment_reference(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_segment_reference(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn segment_reference_skipped(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_segment_reference_skipped(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        segment_reference_enabled: u8,
        segment_reference: u8,
        segment_reference_skipped: u8,
        reserved: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let segment_reference_enabled: u8 =
                unsafe { ::std::mem::transmute(segment_reference_enabled) };
            segment_reference_enabled as u64
        });
        __bindgen_bitfield_unit.set(1usize, 2u8, {
            let segment_reference: u8 = unsafe { ::std::mem::transmute(segment_reference) };
            segment_reference as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let segment_reference_skipped: u8 =
                unsafe { ::std::mem::transmute(segment_reference_skipped) };
            segment_reference_skipped as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let reserved: u8 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _VAEncSegParamVP9__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _VAEncSegParamVP9 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type VAEncSegParamVP9 = _VAEncSegParamVP9;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _VAEncMiscParameterTypeVP9PerSegmantParam {
    pub seg_data: [VAEncSegParamVP9; 8usize],
    pub va_reserved: [u32; 4usize],
}
impl Default for _VAEncMiscParameterTypeVP9PerSegmantParam {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type VAEncMiscParameterTypeVP9PerSegmantParam = _VAEncMiscParameterTypeVP9PerSegmantParam;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _VAConfigAttribValEncAV1 {
    pub bits: _VAConfigAttribValEncAV1__bindgen_ty_1,
    pub value: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VAConfigAttribValEncAV1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _VAConfigAttribValEncAV1__bindgen_ty_1 {
    #[inline]
    pub fn support_128x128_superblock(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_support_128x128_superblock(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn support_filter_intra(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_support_filter_intra(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn support_intra_edge_filter(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_support_intra_edge_filter(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn support_interintra_compound(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_support_interintra_compound(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn support_masked_compound(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_support_masked_compound(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn support_warped_motion(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_support_warped_motion(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn support_palette_mode(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_support_palette_mode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn support_dual_filter(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_support_dual_filter(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn support_jnt_comp(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_support_jnt_comp(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn support_ref_frame_mvs(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_support_ref_frame_mvs(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn support_superres(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_support_superres(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn support_restoration(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(22usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_support_restoration(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(22usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn support_allow_intrabc(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_support_allow_intrabc(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn support_cdef_channel_strength(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(26usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_support_cdef_channel_strength(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(26usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(28usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(28usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        support_128x128_superblock: u32,
        support_filter_intra: u32,
        support_intra_edge_filter: u32,
        support_interintra_compound: u32,
        support_masked_compound: u32,
        support_warped_motion: u32,
        support_palette_mode: u32,
        support_dual_filter: u32,
        support_jnt_comp: u32,
        support_ref_frame_mvs: u32,
        support_superres: u32,
        support_restoration: u32,
        support_allow_intrabc: u32,
        support_cdef_channel_strength: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let support_128x128_superblock: u32 =
                unsafe { ::std::mem::transmute(support_128x128_superblock) };
            support_128x128_superblock as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let support_filter_intra: u32 = unsafe { ::std::mem::transmute(support_filter_intra) };
            support_filter_intra as u64
        });
        __bindgen_bitfield_unit.set(4usize, 2u8, {
            let support_intra_edge_filter: u32 =
                unsafe { ::std::mem::transmute(support_intra_edge_filter) };
            support_intra_edge_filter as u64
        });
        __bindgen_bitfield_unit.set(6usize, 2u8, {
            let support_interintra_compound: u32 =
                unsafe { ::std::mem::transmute(support_interintra_compound) };
            support_interintra_compound as u64
        });
        __bindgen_bitfield_unit.set(8usize, 2u8, {
            let support_masked_compound: u32 =
                unsafe { ::std::mem::transmute(support_masked_compound) };
            support_masked_compound as u64
        });
        __bindgen_bitfield_unit.set(10usize, 2u8, {
            let support_warped_motion: u32 =
                unsafe { ::std::mem::transmute(support_warped_motion) };
            support_warped_motion as u64
        });
        __bindgen_bitfield_unit.set(12usize, 2u8, {
            let support_palette_mode: u32 = unsafe { ::std::mem::transmute(support_palette_mode) };
            support_palette_mode as u64
        });
        __bindgen_bitfield_unit.set(14usize, 2u8, {
            let support_dual_filter: u32 = unsafe { ::std::mem::transmute(support_dual_filter) };
            support_dual_filter as u64
        });
        __bindgen_bitfield_unit.set(16usize, 2u8, {
            let support_jnt_comp: u32 = unsafe { ::std::mem::transmute(support_jnt_comp) };
            support_jnt_comp as u64
        });
        __bindgen_bitfield_unit.set(18usize, 2u8, {
            let support_ref_frame_mvs: u32 =
                unsafe { ::std::mem::transmute(support_ref_frame_mvs) };
            support_ref_frame_mvs as u64
        });
        __bindgen_bitfield_unit.set(20usize, 2u8, {
            let support_superres: u32 = unsafe { ::std::mem::transmute(support_superres) };
            support_superres as u64
        });
        __bindgen_bitfield_unit.set(22usize, 2u8, {
            let support_restoration: u32 = unsafe { ::std::mem::transmute(support_restoration) };
            support_restoration as u64
        });
        __bindgen_bitfield_unit.set(24usize, 2u8, {
            let support_allow_intrabc: u32 =
                unsafe { ::std::mem::transmute(support_allow_intrabc) };
            support_allow_intrabc as u64
        });
        __bindgen_bitfield_unit.set(26usize, 2u8, {
            let support_cdef_channel_strength: u32 =
                unsafe { ::std::mem::transmute(support_cdef_channel_strength) };
            support_cdef_channel_strength as u64
        });
        __bindgen_bitfield_unit.set(28usize, 4u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _VAConfigAttribValEncAV1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type VAConfigAttribValEncAV1 = _VAConfigAttribValEncAV1;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _VAConfigAttribValEncAV1Ext1 {
    pub bits: _VAConfigAttribValEncAV1Ext1__bindgen_ty_1,
    pub value: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VAConfigAttribValEncAV1Ext1__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _VAConfigAttribValEncAV1Ext1__bindgen_ty_1 {
    #[inline]
    pub fn interpolation_filter(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_interpolation_filter(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn min_segid_block_size_accepted(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_min_segid_block_size_accepted(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn segment_feature_support(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_segment_feature_support(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(21usize, 11u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(21usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        interpolation_filter: u32,
        min_segid_block_size_accepted: u32,
        segment_feature_support: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 5u8, {
            let interpolation_filter: u32 = unsafe { ::std::mem::transmute(interpolation_filter) };
            interpolation_filter as u64
        });
        __bindgen_bitfield_unit.set(5usize, 8u8, {
            let min_segid_block_size_accepted: u32 =
                unsafe { ::std::mem::transmute(min_segid_block_size_accepted) };
            min_segid_block_size_accepted as u64
        });
        __bindgen_bitfield_unit.set(13usize, 8u8, {
            let segment_feature_support: u32 =
                unsafe { ::std::mem::transmute(segment_feature_support) };
            segment_feature_support as u64
        });
        __bindgen_bitfield_unit.set(21usize, 11u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _VAConfigAttribValEncAV1Ext1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type VAConfigAttribValEncAV1Ext1 = _VAConfigAttribValEncAV1Ext1;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _VAConfigAttribValEncAV1Ext2 {
    pub bits: _VAConfigAttribValEncAV1Ext2__bindgen_ty_1,
    pub value: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VAConfigAttribValEncAV1Ext2__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _VAConfigAttribValEncAV1Ext2__bindgen_ty_1 {
    #[inline]
    pub fn tile_size_bytes_minus1(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_tile_size_bytes_minus1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn obu_size_bytes_minus1(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_obu_size_bytes_minus1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_mode_support(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_tx_mode_support(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn max_tile_num_minus1(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 13u8) as u32) }
    }
    #[inline]
    pub fn set_max_tile_num_minus1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 13u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        tile_size_bytes_minus1: u32,
        obu_size_bytes_minus1: u32,
        tx_mode_support: u32,
        max_tile_num_minus1: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let tile_size_bytes_minus1: u32 =
                unsafe { ::std::mem::transmute(tile_size_bytes_minus1) };
            tile_size_bytes_minus1 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let obu_size_bytes_minus1: u32 =
                unsafe { ::std::mem::transmute(obu_size_bytes_minus1) };
            obu_size_bytes_minus1 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 3u8, {
            let tx_mode_support: u32 = unsafe { ::std::mem::transmute(tx_mode_support) };
            tx_mode_support as u64
        });
        __bindgen_bitfield_unit.set(7usize, 13u8, {
            let max_tile_num_minus1: u32 = unsafe { ::std::mem::transmute(max_tile_num_minus1) };
            max_tile_num_minus1 as u64
        });
        __bindgen_bitfield_unit.set(20usize, 12u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _VAConfigAttribValEncAV1Ext2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type VAConfigAttribValEncAV1Ext2 = _VAConfigAttribValEncAV1Ext2;
pub mod VAEncPackedHeaderTypeAV1 {
    pub type Type = ::std::os::raw::c_uint;
    pub const VAEncPackedHeaderAV1_SPS: Type = 1;
    pub const VAEncPackedHeaderAV1_PPS: Type = 2;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _VAEncSequenceParameterBufferAV1 {
    pub seq_profile: u8,
    pub seq_level_idx: u8,
    pub seq_tier: u8,
    pub hierarchical_flag: u8,
    pub intra_period: u32,
    pub ip_period: u32,
    pub bits_per_second: u32,
    pub seq_fields: _VAEncSequenceParameterBufferAV1__bindgen_ty_1,
    pub order_hint_bits_minus_1: u8,
    pub va_reserved: [u32; 16usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _VAEncSequenceParameterBufferAV1__bindgen_ty_1 {
    pub bits: _VAEncSequenceParameterBufferAV1__bindgen_ty_1__bindgen_ty_1,
    pub value: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VAEncSequenceParameterBufferAV1__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _VAEncSequenceParameterBufferAV1__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn still_picture(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_still_picture(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn use_128x128_superblock(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_use_128x128_superblock(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enable_filter_intra(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enable_filter_intra(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enable_intra_edge_filter(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enable_intra_edge_filter(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enable_interintra_compound(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enable_interintra_compound(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enable_masked_compound(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enable_masked_compound(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enable_warped_motion(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enable_warped_motion(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enable_dual_filter(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enable_dual_filter(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enable_order_hint(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enable_order_hint(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enable_jnt_comp(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enable_jnt_comp(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enable_ref_frame_mvs(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enable_ref_frame_mvs(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enable_superres(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enable_superres(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enable_cdef(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enable_cdef(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enable_restoration(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enable_restoration(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bit_depth_minus8(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_bit_depth_minus8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn subsampling_x(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_subsampling_x(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn subsampling_y(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_subsampling_y(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved_bits(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 13u8) as u32) }
    }
    #[inline]
    pub fn set_reserved_bits(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 13u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        still_picture: u32,
        use_128x128_superblock: u32,
        enable_filter_intra: u32,
        enable_intra_edge_filter: u32,
        enable_interintra_compound: u32,
        enable_masked_compound: u32,
        enable_warped_motion: u32,
        enable_dual_filter: u32,
        enable_order_hint: u32,
        enable_jnt_comp: u32,
        enable_ref_frame_mvs: u32,
        enable_superres: u32,
        enable_cdef: u32,
        enable_restoration: u32,
        bit_depth_minus8: u32,
        subsampling_x: u32,
        subsampling_y: u32,
        reserved_bits: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let still_picture: u32 = unsafe { ::std::mem::transmute(still_picture) };
            still_picture as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let use_128x128_superblock: u32 =
                unsafe { ::std::mem::transmute(use_128x128_superblock) };
            use_128x128_superblock as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let enable_filter_intra: u32 = unsafe { ::std::mem::transmute(enable_filter_intra) };
            enable_filter_intra as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let enable_intra_edge_filter: u32 =
                unsafe { ::std::mem::transmute(enable_intra_edge_filter) };
            enable_intra_edge_filter as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let enable_interintra_compound: u32 =
                unsafe { ::std::mem::transmute(enable_interintra_compound) };
            enable_interintra_compound as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let enable_masked_compound: u32 =
                unsafe { ::std::mem::transmute(enable_masked_compound) };
            enable_masked_compound as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let enable_warped_motion: u32 = unsafe { ::std::mem::transmute(enable_warped_motion) };
            enable_warped_motion as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let enable_dual_filter: u32 = unsafe { ::std::mem::transmute(enable_dual_filter) };
            enable_dual_filter as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let enable_order_hint: u32 = unsafe { ::std::mem::transmute(enable_order_hint) };
            enable_order_hint as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let enable_jnt_comp: u32 = unsafe { ::std::mem::transmute(enable_jnt_comp) };
            enable_jnt_comp as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let enable_ref_frame_mvs: u32 = unsafe { ::std::mem::transmute(enable_ref_frame_mvs) };
            enable_ref_frame_mvs as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let enable_superres: u32 = unsafe { ::std::mem::transmute(enable_superres) };
            enable_superres as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let enable_cdef: u32 = unsafe { ::std::mem::transmute(enable_cdef) };
            enable_cdef as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let enable_restoration: u32 = unsafe { ::std::mem::transmute(enable_restoration) };
            enable_restoration as u64
        });
        __bindgen_bitfield_unit.set(14usize, 3u8, {
            let bit_depth_minus8: u32 = unsafe { ::std::mem::transmute(bit_depth_minus8) };
            bit_depth_minus8 as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let subsampling_x: u32 = unsafe { ::std::mem::transmute(subsampling_x) };
            subsampling_x as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let subsampling_y: u32 = unsafe { ::std::mem::transmute(subsampling_y) };
            subsampling_y as u64
        });
        __bindgen_bitfield_unit.set(19usize, 13u8, {
            let reserved_bits: u32 = unsafe { ::std::mem::transmute(reserved_bits) };
            reserved_bits as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _VAEncSequenceParameterBufferAV1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _VAEncSequenceParameterBufferAV1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type VAEncSequenceParameterBufferAV1 = _VAEncSequenceParameterBufferAV1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _VAEncSegParamAV1 {
    pub seg_flags: _VAEncSegParamAV1__bindgen_ty_1,
    pub segment_number: u8,
    pub feature_data: [[i16; 8usize]; 8usize],
    pub feature_mask: [u8; 8usize],
    pub va_reserved: [u32; 4usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _VAEncSegParamAV1__bindgen_ty_1 {
    pub bits: _VAEncSegParamAV1__bindgen_ty_1__bindgen_ty_1,
    pub value: u8,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VAEncSegParamAV1__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl _VAEncSegParamAV1__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn segmentation_enabled(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_segmentation_enabled(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn segmentation_update_map(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_segmentation_update_map(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn segmentation_temporal_update(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_segmentation_temporal_update(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 5u8) as u8) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        segmentation_enabled: u8,
        segmentation_update_map: u8,
        segmentation_temporal_update: u8,
        reserved: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let segmentation_enabled: u8 = unsafe { ::std::mem::transmute(segmentation_enabled) };
            segmentation_enabled as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let segmentation_update_map: u8 =
                unsafe { ::std::mem::transmute(segmentation_update_map) };
            segmentation_update_map as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let segmentation_temporal_update: u8 =
                unsafe { ::std::mem::transmute(segmentation_temporal_update) };
            segmentation_temporal_update as u64
        });
        __bindgen_bitfield_unit.set(3usize, 5u8, {
            let reserved: u8 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _VAEncSegParamAV1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _VAEncSegParamAV1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type VAEncSegParamAV1 = _VAEncSegParamAV1;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _VAEncSegMapBufferAV1 {
    pub segmentMapDataSize: u32,
    pub pSegmentMap: *mut u8,
}
impl Default for _VAEncSegMapBufferAV1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type VAEncSegMapBufferAV1 = _VAEncSegMapBufferAV1;
pub mod VAEncTransformationTypeAV1 {
    pub type Type = ::std::os::raw::c_uint;
    pub const VAAV1EncTransformationIdentity: Type = 0;
    pub const VAAV1EncTransformationTranslation: Type = 1;
    pub const VAAV1EncTransformationRotzoom: Type = 2;
    pub const VAAV1EncTransformationAffine: Type = 3;
    pub const VAAV1EncTransformationCount: Type = 4;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _VAEncWarpedMotionParamsAV1 {
    pub wmtype: VAEncTransformationTypeAV1::Type,
    pub wmmat: [i32; 8usize],
    pub invalid: u8,
    pub va_reserved: [u32; 4usize],
}
impl Default for _VAEncWarpedMotionParamsAV1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type VAEncWarpedMotionParamsAV1 = _VAEncWarpedMotionParamsAV1;
#[repr(C)]
#[derive(Copy, Clone)]
pub union VARefFrameCtrlAV1 {
    pub fields: VARefFrameCtrlAV1__bindgen_ty_1,
    pub value: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct VARefFrameCtrlAV1__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl VARefFrameCtrlAV1__bindgen_ty_1 {
    #[inline]
    pub fn search_idx0(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_search_idx0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn search_idx1(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_search_idx1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn search_idx2(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_search_idx2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn search_idx3(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_search_idx3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn search_idx4(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_search_idx4(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn search_idx5(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_search_idx5(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn search_idx6(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_search_idx6(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(21usize, 11u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(21usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        search_idx0: u32,
        search_idx1: u32,
        search_idx2: u32,
        search_idx3: u32,
        search_idx4: u32,
        search_idx5: u32,
        search_idx6: u32,
        Reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let search_idx0: u32 = unsafe { ::std::mem::transmute(search_idx0) };
            search_idx0 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 3u8, {
            let search_idx1: u32 = unsafe { ::std::mem::transmute(search_idx1) };
            search_idx1 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 3u8, {
            let search_idx2: u32 = unsafe { ::std::mem::transmute(search_idx2) };
            search_idx2 as u64
        });
        __bindgen_bitfield_unit.set(9usize, 3u8, {
            let search_idx3: u32 = unsafe { ::std::mem::transmute(search_idx3) };
            search_idx3 as u64
        });
        __bindgen_bitfield_unit.set(12usize, 3u8, {
            let search_idx4: u32 = unsafe { ::std::mem::transmute(search_idx4) };
            search_idx4 as u64
        });
        __bindgen_bitfield_unit.set(15usize, 3u8, {
            let search_idx5: u32 = unsafe { ::std::mem::transmute(search_idx5) };
            search_idx5 as u64
        });
        __bindgen_bitfield_unit.set(18usize, 3u8, {
            let search_idx6: u32 = unsafe { ::std::mem::transmute(search_idx6) };
            search_idx6 as u64
        });
        __bindgen_bitfield_unit.set(21usize, 11u8, {
            let Reserved: u32 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for VARefFrameCtrlAV1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _VAEncPictureParameterBufferAV1 {
    pub frame_width_minus_1: u16,
    pub frame_height_minus_1: u16,
    pub reconstructed_frame: VASurfaceID,
    pub coded_buf: VABufferID,
    pub reference_frames: [VASurfaceID; 8usize],
    pub ref_frame_idx: [u8; 7usize],
    pub hierarchical_level_plus1: u8,
    pub primary_ref_frame: u8,
    pub order_hint: u8,
    pub refresh_frame_flags: u8,
    pub reserved8bits1: u8,
    pub ref_frame_ctrl_l0: VARefFrameCtrlAV1,
    pub ref_frame_ctrl_l1: VARefFrameCtrlAV1,
    pub picture_flags: _VAEncPictureParameterBufferAV1__bindgen_ty_1,
    pub seg_id_block_size: u8,
    pub num_tile_groups_minus1: u8,
    pub temporal_id: u8,
    pub filter_level: [u8; 2usize],
    pub filter_level_u: u8,
    pub filter_level_v: u8,
    pub loop_filter_flags: _VAEncPictureParameterBufferAV1__bindgen_ty_2,
    pub superres_scale_denominator: u8,
    pub interpolation_filter: u8,
    pub ref_deltas: [i8; 8usize],
    pub mode_deltas: [i8; 2usize],
    pub base_qindex: u8,
    pub y_dc_delta_q: i8,
    pub u_dc_delta_q: i8,
    pub u_ac_delta_q: i8,
    pub v_dc_delta_q: i8,
    pub v_ac_delta_q: i8,
    pub min_base_qindex: u8,
    pub max_base_qindex: u8,
    pub qmatrix_flags: _VAEncPictureParameterBufferAV1__bindgen_ty_3,
    pub reserved16bits1: u16,
    pub mode_control_flags: _VAEncPictureParameterBufferAV1__bindgen_ty_4,
    pub segments: VAEncSegParamAV1,
    pub tile_cols: u8,
    pub tile_rows: u8,
    pub reserved16bits2: u16,
    pub width_in_sbs_minus_1: [u16; 63usize],
    pub height_in_sbs_minus_1: [u16; 63usize],
    pub context_update_tile_id: u16,
    pub cdef_damping_minus_3: u8,
    pub cdef_bits: u8,
    pub cdef_y_strengths: [u8; 8usize],
    pub cdef_uv_strengths: [u8; 8usize],
    pub loop_restoration_flags: _VAEncPictureParameterBufferAV1__bindgen_ty_5,
    pub wm: [VAEncWarpedMotionParamsAV1; 7usize],
    pub bit_offset_qindex: u32,
    pub bit_offset_segmentation: u32,
    pub bit_offset_loopfilter_params: u32,
    pub bit_offset_cdef_params: u32,
    pub size_in_bits_cdef_params: u32,
    pub byte_offset_frame_hdr_obu_size: u32,
    pub size_in_bits_frame_hdr_obu: u32,
    pub tile_group_obu_hdr_info: _VAEncPictureParameterBufferAV1__bindgen_ty_6,
    pub number_skip_frames: u8,
    pub reserved16bits3: u16,
    pub skip_frames_reduced_size: i32,
    pub va_reserved: [u32; 16usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _VAEncPictureParameterBufferAV1__bindgen_ty_1 {
    pub bits: _VAEncPictureParameterBufferAV1__bindgen_ty_1__bindgen_ty_1,
    pub value: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VAEncPictureParameterBufferAV1__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _VAEncPictureParameterBufferAV1__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn frame_type(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_frame_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn error_resilient_mode(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_error_resilient_mode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn disable_cdf_update(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disable_cdf_update(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn use_superres(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_use_superres(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn allow_high_precision_mv(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_allow_high_precision_mv(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn use_ref_frame_mvs(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_use_ref_frame_mvs(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn disable_frame_end_update_cdf(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disable_frame_end_update_cdf(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reduced_tx_set(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reduced_tx_set(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enable_frame_obu(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enable_frame_obu(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn long_term_reference(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_long_term_reference(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn disable_frame_recon(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disable_frame_recon(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn allow_intrabc(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_allow_intrabc(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn palette_mode_enable(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_palette_mode_enable(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 18u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 18u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        frame_type: u32,
        error_resilient_mode: u32,
        disable_cdf_update: u32,
        use_superres: u32,
        allow_high_precision_mv: u32,
        use_ref_frame_mvs: u32,
        disable_frame_end_update_cdf: u32,
        reduced_tx_set: u32,
        enable_frame_obu: u32,
        long_term_reference: u32,
        disable_frame_recon: u32,
        allow_intrabc: u32,
        palette_mode_enable: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let frame_type: u32 = unsafe { ::std::mem::transmute(frame_type) };
            frame_type as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let error_resilient_mode: u32 = unsafe { ::std::mem::transmute(error_resilient_mode) };
            error_resilient_mode as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let disable_cdf_update: u32 = unsafe { ::std::mem::transmute(disable_cdf_update) };
            disable_cdf_update as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let use_superres: u32 = unsafe { ::std::mem::transmute(use_superres) };
            use_superres as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let allow_high_precision_mv: u32 =
                unsafe { ::std::mem::transmute(allow_high_precision_mv) };
            allow_high_precision_mv as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let use_ref_frame_mvs: u32 = unsafe { ::std::mem::transmute(use_ref_frame_mvs) };
            use_ref_frame_mvs as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let disable_frame_end_update_cdf: u32 =
                unsafe { ::std::mem::transmute(disable_frame_end_update_cdf) };
            disable_frame_end_update_cdf as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let reduced_tx_set: u32 = unsafe { ::std::mem::transmute(reduced_tx_set) };
            reduced_tx_set as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let enable_frame_obu: u32 = unsafe { ::std::mem::transmute(enable_frame_obu) };
            enable_frame_obu as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let long_term_reference: u32 = unsafe { ::std::mem::transmute(long_term_reference) };
            long_term_reference as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let disable_frame_recon: u32 = unsafe { ::std::mem::transmute(disable_frame_recon) };
            disable_frame_recon as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let allow_intrabc: u32 = unsafe { ::std::mem::transmute(allow_intrabc) };
            allow_intrabc as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let palette_mode_enable: u32 = unsafe { ::std::mem::transmute(palette_mode_enable) };
            palette_mode_enable as u64
        });
        __bindgen_bitfield_unit.set(14usize, 18u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _VAEncPictureParameterBufferAV1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _VAEncPictureParameterBufferAV1__bindgen_ty_2 {
    pub bits: _VAEncPictureParameterBufferAV1__bindgen_ty_2__bindgen_ty_1,
    pub value: u8,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VAEncPictureParameterBufferAV1__bindgen_ty_2__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl _VAEncPictureParameterBufferAV1__bindgen_ty_2__bindgen_ty_1 {
    #[inline]
    pub fn sharpness_level(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_sharpness_level(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn mode_ref_delta_enabled(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mode_ref_delta_enabled(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mode_ref_delta_update(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mode_ref_delta_update(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        sharpness_level: u8,
        mode_ref_delta_enabled: u8,
        mode_ref_delta_update: u8,
        reserved: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let sharpness_level: u8 = unsafe { ::std::mem::transmute(sharpness_level) };
            sharpness_level as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let mode_ref_delta_enabled: u8 =
                unsafe { ::std::mem::transmute(mode_ref_delta_enabled) };
            mode_ref_delta_enabled as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let mode_ref_delta_update: u8 = unsafe { ::std::mem::transmute(mode_ref_delta_update) };
            mode_ref_delta_update as u64
        });
        __bindgen_bitfield_unit.set(5usize, 3u8, {
            let reserved: u8 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _VAEncPictureParameterBufferAV1__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _VAEncPictureParameterBufferAV1__bindgen_ty_3 {
    pub bits: _VAEncPictureParameterBufferAV1__bindgen_ty_3__bindgen_ty_1,
    pub value: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VAEncPictureParameterBufferAV1__bindgen_ty_3__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl _VAEncPictureParameterBufferAV1__bindgen_ty_3__bindgen_ty_1 {
    #[inline]
    pub fn using_qmatrix(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_using_qmatrix(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn qm_y(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_qm_y(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn qm_u(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_qm_u(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn qm_v(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_qm_v(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        using_qmatrix: u16,
        qm_y: u16,
        qm_u: u16,
        qm_v: u16,
        reserved: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let using_qmatrix: u16 = unsafe { ::std::mem::transmute(using_qmatrix) };
            using_qmatrix as u64
        });
        __bindgen_bitfield_unit.set(1usize, 4u8, {
            let qm_y: u16 = unsafe { ::std::mem::transmute(qm_y) };
            qm_y as u64
        });
        __bindgen_bitfield_unit.set(5usize, 4u8, {
            let qm_u: u16 = unsafe { ::std::mem::transmute(qm_u) };
            qm_u as u64
        });
        __bindgen_bitfield_unit.set(9usize, 4u8, {
            let qm_v: u16 = unsafe { ::std::mem::transmute(qm_v) };
            qm_v as u64
        });
        __bindgen_bitfield_unit.set(13usize, 3u8, {
            let reserved: u16 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _VAEncPictureParameterBufferAV1__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _VAEncPictureParameterBufferAV1__bindgen_ty_4 {
    pub bits: _VAEncPictureParameterBufferAV1__bindgen_ty_4__bindgen_ty_1,
    pub value: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VAEncPictureParameterBufferAV1__bindgen_ty_4__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _VAEncPictureParameterBufferAV1__bindgen_ty_4__bindgen_ty_1 {
    #[inline]
    pub fn delta_q_present(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_delta_q_present(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn delta_q_res(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_delta_q_res(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn delta_lf_present(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_delta_lf_present(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn delta_lf_res(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_delta_lf_res(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn delta_lf_multi(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_delta_lf_multi(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_mode(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_tx_mode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn reference_mode(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_reference_mode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn skip_mode_present(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_skip_mode_present(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        delta_q_present: u32,
        delta_q_res: u32,
        delta_lf_present: u32,
        delta_lf_res: u32,
        delta_lf_multi: u32,
        tx_mode: u32,
        reference_mode: u32,
        skip_mode_present: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let delta_q_present: u32 = unsafe { ::std::mem::transmute(delta_q_present) };
            delta_q_present as u64
        });
        __bindgen_bitfield_unit.set(1usize, 2u8, {
            let delta_q_res: u32 = unsafe { ::std::mem::transmute(delta_q_res) };
            delta_q_res as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let delta_lf_present: u32 = unsafe { ::std::mem::transmute(delta_lf_present) };
            delta_lf_present as u64
        });
        __bindgen_bitfield_unit.set(4usize, 2u8, {
            let delta_lf_res: u32 = unsafe { ::std::mem::transmute(delta_lf_res) };
            delta_lf_res as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let delta_lf_multi: u32 = unsafe { ::std::mem::transmute(delta_lf_multi) };
            delta_lf_multi as u64
        });
        __bindgen_bitfield_unit.set(7usize, 2u8, {
            let tx_mode: u32 = unsafe { ::std::mem::transmute(tx_mode) };
            tx_mode as u64
        });
        __bindgen_bitfield_unit.set(9usize, 2u8, {
            let reference_mode: u32 = unsafe { ::std::mem::transmute(reference_mode) };
            reference_mode as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let skip_mode_present: u32 = unsafe { ::std::mem::transmute(skip_mode_present) };
            skip_mode_present as u64
        });
        __bindgen_bitfield_unit.set(12usize, 20u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _VAEncPictureParameterBufferAV1__bindgen_ty_4 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _VAEncPictureParameterBufferAV1__bindgen_ty_5 {
    pub bits: _VAEncPictureParameterBufferAV1__bindgen_ty_5__bindgen_ty_1,
    pub value: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VAEncPictureParameterBufferAV1__bindgen_ty_5__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl _VAEncPictureParameterBufferAV1__bindgen_ty_5__bindgen_ty_1 {
    #[inline]
    pub fn yframe_restoration_type(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_yframe_restoration_type(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn cbframe_restoration_type(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_cbframe_restoration_type(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn crframe_restoration_type(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_crframe_restoration_type(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn lr_unit_shift(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_lr_unit_shift(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn lr_uv_shift(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_lr_uv_shift(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 7u8) as u16) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        yframe_restoration_type: u16,
        cbframe_restoration_type: u16,
        crframe_restoration_type: u16,
        lr_unit_shift: u16,
        lr_uv_shift: u16,
        reserved: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let yframe_restoration_type: u16 =
                unsafe { ::std::mem::transmute(yframe_restoration_type) };
            yframe_restoration_type as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let cbframe_restoration_type: u16 =
                unsafe { ::std::mem::transmute(cbframe_restoration_type) };
            cbframe_restoration_type as u64
        });
        __bindgen_bitfield_unit.set(4usize, 2u8, {
            let crframe_restoration_type: u16 =
                unsafe { ::std::mem::transmute(crframe_restoration_type) };
            crframe_restoration_type as u64
        });
        __bindgen_bitfield_unit.set(6usize, 2u8, {
            let lr_unit_shift: u16 = unsafe { ::std::mem::transmute(lr_unit_shift) };
            lr_unit_shift as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let lr_uv_shift: u16 = unsafe { ::std::mem::transmute(lr_uv_shift) };
            lr_uv_shift as u64
        });
        __bindgen_bitfield_unit.set(9usize, 7u8, {
            let reserved: u16 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _VAEncPictureParameterBufferAV1__bindgen_ty_5 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _VAEncPictureParameterBufferAV1__bindgen_ty_6 {
    pub bits: _VAEncPictureParameterBufferAV1__bindgen_ty_6__bindgen_ty_1,
    pub value: u8,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VAEncPictureParameterBufferAV1__bindgen_ty_6__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl _VAEncPictureParameterBufferAV1__bindgen_ty_6__bindgen_ty_1 {
    #[inline]
    pub fn obu_extension_flag(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_obu_extension_flag(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn obu_has_size_field(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_obu_has_size_field(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn temporal_id(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_temporal_id(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn spatial_id(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_spatial_id(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        obu_extension_flag: u8,
        obu_has_size_field: u8,
        temporal_id: u8,
        spatial_id: u8,
        reserved: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let obu_extension_flag: u8 = unsafe { ::std::mem::transmute(obu_extension_flag) };
            obu_extension_flag as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let obu_has_size_field: u8 = unsafe { ::std::mem::transmute(obu_has_size_field) };
            obu_has_size_field as u64
        });
        __bindgen_bitfield_unit.set(2usize, 3u8, {
            let temporal_id: u8 = unsafe { ::std::mem::transmute(temporal_id) };
            temporal_id as u64
        });
        __bindgen_bitfield_unit.set(5usize, 2u8, {
            let spatial_id: u8 = unsafe { ::std::mem::transmute(spatial_id) };
            spatial_id as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let reserved: u8 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _VAEncPictureParameterBufferAV1__bindgen_ty_6 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _VAEncPictureParameterBufferAV1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type VAEncPictureParameterBufferAV1 = _VAEncPictureParameterBufferAV1;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VAEncTileGroupBufferAV1 {
    pub tg_start: u8,
    pub tg_end: u8,
    pub va_reserved: [u32; 4usize],
}
pub type VAEncTileGroupBufferAV1 = _VAEncTileGroupBufferAV1;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _VAEncMiscParameterFEIFrameControlH264 {
    pub function: u32,
    pub mb_ctrl: VABufferID,
    pub distortion: VABufferID,
    pub mv_data: VABufferID,
    pub mb_code_data: VABufferID,
    pub qp: VABufferID,
    pub mv_predictor: VABufferID,
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 16usize]>,
    pub max_frame_size: u32,
    pub num_passes: u32,
    pub delta_qp: *mut u8,
    pub reserved3: [u32; 4usize],
}
impl Default for _VAEncMiscParameterFEIFrameControlH264 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _VAEncMiscParameterFEIFrameControlH264 {
    #[inline]
    pub fn num_mv_predictors_l0(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_num_mv_predictors_l0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn num_mv_predictors_l1(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_num_mv_predictors_l1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn search_path(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_search_path(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn len_sp(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(40usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_len_sp(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(40usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(48usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(48usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn sub_mb_part_mask(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(64usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_sub_mb_part_mask(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(64usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn intra_part_mask(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(71usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_intra_part_mask(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(71usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn multi_pred_l0(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(76usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_multi_pred_l0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(76usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn multi_pred_l1(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(77usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_multi_pred_l1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(77usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sub_pel_mode(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(78usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_sub_pel_mode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(78usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn inter_sad(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(80usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_inter_sad(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(80usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn intra_sad(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(82usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_intra_sad(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(82usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn distortion_type(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(84usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_distortion_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(84usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn repartition_check_enable(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(85usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_repartition_check_enable(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(85usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn adaptive_search(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(86usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_adaptive_search(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(86usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mv_predictor_enable(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(87usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mv_predictor_enable(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(87usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mb_qp(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(88usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mb_qp(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(88usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mb_input(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(89usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mb_input(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(89usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mb_size_ctrl(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(90usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mb_size_ctrl(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(90usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn colocated_mb_distortion(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(91usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_colocated_mb_distortion(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(91usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved1(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(92usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(92usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn ref_width(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(96usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_ref_width(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(96usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn ref_height(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(104usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_ref_height(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(104usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn search_window(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(112usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_search_window(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(112usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved2(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(116usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_reserved2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(116usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        num_mv_predictors_l0: u32,
        num_mv_predictors_l1: u32,
        search_path: u32,
        len_sp: u32,
        reserved0: u32,
        sub_mb_part_mask: u32,
        intra_part_mask: u32,
        multi_pred_l0: u32,
        multi_pred_l1: u32,
        sub_pel_mode: u32,
        inter_sad: u32,
        intra_sad: u32,
        distortion_type: u32,
        repartition_check_enable: u32,
        adaptive_search: u32,
        mv_predictor_enable: u32,
        mb_qp: u32,
        mb_input: u32,
        mb_size_ctrl: u32,
        colocated_mb_distortion: u32,
        reserved1: u32,
        ref_width: u32,
        ref_height: u32,
        search_window: u32,
        reserved2: u32,
    ) -> __BindgenBitfieldUnit<[u8; 16usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 16usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let num_mv_predictors_l0: u32 = unsafe { ::std::mem::transmute(num_mv_predictors_l0) };
            num_mv_predictors_l0 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let num_mv_predictors_l1: u32 = unsafe { ::std::mem::transmute(num_mv_predictors_l1) };
            num_mv_predictors_l1 as u64
        });
        __bindgen_bitfield_unit.set(32usize, 8u8, {
            let search_path: u32 = unsafe { ::std::mem::transmute(search_path) };
            search_path as u64
        });
        __bindgen_bitfield_unit.set(40usize, 8u8, {
            let len_sp: u32 = unsafe { ::std::mem::transmute(len_sp) };
            len_sp as u64
        });
        __bindgen_bitfield_unit.set(48usize, 16u8, {
            let reserved0: u32 = unsafe { ::std::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(64usize, 7u8, {
            let sub_mb_part_mask: u32 = unsafe { ::std::mem::transmute(sub_mb_part_mask) };
            sub_mb_part_mask as u64
        });
        __bindgen_bitfield_unit.set(71usize, 5u8, {
            let intra_part_mask: u32 = unsafe { ::std::mem::transmute(intra_part_mask) };
            intra_part_mask as u64
        });
        __bindgen_bitfield_unit.set(76usize, 1u8, {
            let multi_pred_l0: u32 = unsafe { ::std::mem::transmute(multi_pred_l0) };
            multi_pred_l0 as u64
        });
        __bindgen_bitfield_unit.set(77usize, 1u8, {
            let multi_pred_l1: u32 = unsafe { ::std::mem::transmute(multi_pred_l1) };
            multi_pred_l1 as u64
        });
        __bindgen_bitfield_unit.set(78usize, 2u8, {
            let sub_pel_mode: u32 = unsafe { ::std::mem::transmute(sub_pel_mode) };
            sub_pel_mode as u64
        });
        __bindgen_bitfield_unit.set(80usize, 2u8, {
            let inter_sad: u32 = unsafe { ::std::mem::transmute(inter_sad) };
            inter_sad as u64
        });
        __bindgen_bitfield_unit.set(82usize, 2u8, {
            let intra_sad: u32 = unsafe { ::std::mem::transmute(intra_sad) };
            intra_sad as u64
        });
        __bindgen_bitfield_unit.set(84usize, 1u8, {
            let distortion_type: u32 = unsafe { ::std::mem::transmute(distortion_type) };
            distortion_type as u64
        });
        __bindgen_bitfield_unit.set(85usize, 1u8, {
            let repartition_check_enable: u32 =
                unsafe { ::std::mem::transmute(repartition_check_enable) };
            repartition_check_enable as u64
        });
        __bindgen_bitfield_unit.set(86usize, 1u8, {
            let adaptive_search: u32 = unsafe { ::std::mem::transmute(adaptive_search) };
            adaptive_search as u64
        });
        __bindgen_bitfield_unit.set(87usize, 1u8, {
            let mv_predictor_enable: u32 = unsafe { ::std::mem::transmute(mv_predictor_enable) };
            mv_predictor_enable as u64
        });
        __bindgen_bitfield_unit.set(88usize, 1u8, {
            let mb_qp: u32 = unsafe { ::std::mem::transmute(mb_qp) };
            mb_qp as u64
        });
        __bindgen_bitfield_unit.set(89usize, 1u8, {
            let mb_input: u32 = unsafe { ::std::mem::transmute(mb_input) };
            mb_input as u64
        });
        __bindgen_bitfield_unit.set(90usize, 1u8, {
            let mb_size_ctrl: u32 = unsafe { ::std::mem::transmute(mb_size_ctrl) };
            mb_size_ctrl as u64
        });
        __bindgen_bitfield_unit.set(91usize, 1u8, {
            let colocated_mb_distortion: u32 =
                unsafe { ::std::mem::transmute(colocated_mb_distortion) };
            colocated_mb_distortion as u64
        });
        __bindgen_bitfield_unit.set(92usize, 4u8, {
            let reserved1: u32 = unsafe { ::std::mem::transmute(reserved1) };
            reserved1 as u64
        });
        __bindgen_bitfield_unit.set(96usize, 8u8, {
            let ref_width: u32 = unsafe { ::std::mem::transmute(ref_width) };
            ref_width as u64
        });
        __bindgen_bitfield_unit.set(104usize, 8u8, {
            let ref_height: u32 = unsafe { ::std::mem::transmute(ref_height) };
            ref_height as u64
        });
        __bindgen_bitfield_unit.set(112usize, 4u8, {
            let search_window: u32 = unsafe { ::std::mem::transmute(search_window) };
            search_window as u64
        });
        __bindgen_bitfield_unit.set(116usize, 12u8, {
            let reserved2: u32 = unsafe { ::std::mem::transmute(reserved2) };
            reserved2 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type VAEncMiscParameterFEIFrameControlH264 = _VAEncMiscParameterFEIFrameControlH264;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VAEncFEIMBControlH264 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub reserved1: u32,
    pub reserved2: u32,
    pub _bitfield_align_2: [u16; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _VAEncFEIMBControlH264 {
    #[inline]
    pub fn force_to_intra(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_force_to_intra(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn force_to_skip(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_force_to_skip(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn force_to_nonskip(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_force_to_nonskip(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enable_direct_bias_adjustment(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enable_direct_bias_adjustment(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enable_motion_bias_adjustment(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enable_motion_bias_adjustment(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ext_mv_cost_scaling_factor(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_ext_mv_cost_scaling_factor(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        force_to_intra: u32,
        force_to_skip: u32,
        force_to_nonskip: u32,
        enable_direct_bias_adjustment: u32,
        enable_motion_bias_adjustment: u32,
        ext_mv_cost_scaling_factor: u32,
        reserved0: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let force_to_intra: u32 = unsafe { ::std::mem::transmute(force_to_intra) };
            force_to_intra as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let force_to_skip: u32 = unsafe { ::std::mem::transmute(force_to_skip) };
            force_to_skip as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let force_to_nonskip: u32 = unsafe { ::std::mem::transmute(force_to_nonskip) };
            force_to_nonskip as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let enable_direct_bias_adjustment: u32 =
                unsafe { ::std::mem::transmute(enable_direct_bias_adjustment) };
            enable_direct_bias_adjustment as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let enable_motion_bias_adjustment: u32 =
                unsafe { ::std::mem::transmute(enable_motion_bias_adjustment) };
            enable_motion_bias_adjustment as u64
        });
        __bindgen_bitfield_unit.set(5usize, 3u8, {
            let ext_mv_cost_scaling_factor: u32 =
                unsafe { ::std::mem::transmute(ext_mv_cost_scaling_factor) };
            ext_mv_cost_scaling_factor as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let reserved0: u32 = unsafe { ::std::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn reserved3(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_reserved3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn target_size_in_word(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_target_size_in_word(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn max_size_in_word(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_max_size_in_word(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_2(
        reserved3: u32,
        target_size_in_word: u32,
        max_size_in_word: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let reserved3: u32 = unsafe { ::std::mem::transmute(reserved3) };
            reserved3 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let target_size_in_word: u32 = unsafe { ::std::mem::transmute(target_size_in_word) };
            target_size_in_word as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let max_size_in_word: u32 = unsafe { ::std::mem::transmute(max_size_in_word) };
            max_size_in_word as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type VAEncFEIMBControlH264 = _VAEncFEIMBControlH264;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VAEncFEIMVPredictorH264 {
    pub ref_idx: [_VAEncFEIMVPredictorH264__bindgen_ty_1; 4usize],
    pub reserved: u32,
    pub mv: [VAMotionVector; 4usize],
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VAEncFEIMVPredictorH264__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl _VAEncFEIMVPredictorH264__bindgen_ty_1 {
    #[inline]
    pub fn ref_idx_l0(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_ref_idx_l0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn ref_idx_l1(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_ref_idx_l1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(ref_idx_l0: u8, ref_idx_l1: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let ref_idx_l0: u8 = unsafe { ::std::mem::transmute(ref_idx_l0) };
            ref_idx_l0 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let ref_idx_l1: u8 = unsafe { ::std::mem::transmute(ref_idx_l1) };
            ref_idx_l1 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type VAEncFEIMVPredictorH264 = _VAEncFEIMVPredictorH264;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _VAEncFEIMBCodeH264 {
    pub reserved0: [u32; 3usize],
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 16usize]>,
    pub mb_mode: _VAEncFEIMBCodeH264__bindgen_ty_1,
    pub _bitfield_align_2: [u16; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub reserved9: [u32; 4usize],
    pub reserved10: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _VAEncFEIMBCodeH264__bindgen_ty_1 {
    pub intra_mb: _VAEncFEIMBCodeH264__bindgen_ty_1__bindgen_ty_1,
    pub inter_mb: _VAEncFEIMBCodeH264__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VAEncFEIMBCodeH264__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 12usize]>,
}
impl _VAEncFEIMBCodeH264__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn luma_intra_pred_modes0(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_luma_intra_pred_modes0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn luma_intra_pred_modes1(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_luma_intra_pred_modes1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn luma_intra_pred_modes2(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_luma_intra_pred_modes2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn luma_intra_pred_modes3(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(48usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_luma_intra_pred_modes3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(48usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn chroma_intra_pred_mode(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(64usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_chroma_intra_pred_mode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(64usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn intra_pred_avail_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(66usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_intra_pred_avail_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(66usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn intra_pred_avail_flagF(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(71usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_intra_pred_avail_flagF(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(71usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved6(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(72usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_reserved6(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(72usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        luma_intra_pred_modes0: u32,
        luma_intra_pred_modes1: u32,
        luma_intra_pred_modes2: u32,
        luma_intra_pred_modes3: u32,
        chroma_intra_pred_mode: u32,
        intra_pred_avail_flag: u32,
        intra_pred_avail_flagF: u32,
        reserved6: u32,
    ) -> __BindgenBitfieldUnit<[u8; 12usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 12usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let luma_intra_pred_modes0: u32 =
                unsafe { ::std::mem::transmute(luma_intra_pred_modes0) };
            luma_intra_pred_modes0 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let luma_intra_pred_modes1: u32 =
                unsafe { ::std::mem::transmute(luma_intra_pred_modes1) };
            luma_intra_pred_modes1 as u64
        });
        __bindgen_bitfield_unit.set(32usize, 16u8, {
            let luma_intra_pred_modes2: u32 =
                unsafe { ::std::mem::transmute(luma_intra_pred_modes2) };
            luma_intra_pred_modes2 as u64
        });
        __bindgen_bitfield_unit.set(48usize, 16u8, {
            let luma_intra_pred_modes3: u32 =
                unsafe { ::std::mem::transmute(luma_intra_pred_modes3) };
            luma_intra_pred_modes3 as u64
        });
        __bindgen_bitfield_unit.set(64usize, 2u8, {
            let chroma_intra_pred_mode: u32 =
                unsafe { ::std::mem::transmute(chroma_intra_pred_mode) };
            chroma_intra_pred_mode as u64
        });
        __bindgen_bitfield_unit.set(66usize, 5u8, {
            let intra_pred_avail_flag: u32 =
                unsafe { ::std::mem::transmute(intra_pred_avail_flag) };
            intra_pred_avail_flag as u64
        });
        __bindgen_bitfield_unit.set(71usize, 1u8, {
            let intra_pred_avail_flagF: u32 =
                unsafe { ::std::mem::transmute(intra_pred_avail_flagF) };
            intra_pred_avail_flagF as u64
        });
        __bindgen_bitfield_unit.set(72usize, 24u8, {
            let reserved6: u32 = unsafe { ::std::mem::transmute(reserved6) };
            reserved6 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VAEncFEIMBCodeH264__bindgen_ty_1__bindgen_ty_2 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 12usize]>,
}
impl _VAEncFEIMBCodeH264__bindgen_ty_1__bindgen_ty_2 {
    #[inline]
    pub fn sub_mb_shapes(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_sub_mb_shapes(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn sub_mb_pred_modes(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_sub_mb_pred_modes(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved7(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_reserved7(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn ref_idx_l0_0(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_ref_idx_l0_0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn ref_idx_l0_1(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(40usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_ref_idx_l0_1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(40usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn ref_idx_l0_2(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(48usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_ref_idx_l0_2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(48usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn ref_idx_l0_3(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(56usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_ref_idx_l0_3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(56usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn ref_idx_l1_0(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(64usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_ref_idx_l1_0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(64usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn ref_idx_l1_1(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(72usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_ref_idx_l1_1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(72usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn ref_idx_l1_2(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(80usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_ref_idx_l1_2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(80usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn ref_idx_l1_3(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(88usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_ref_idx_l1_3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(88usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        sub_mb_shapes: u32,
        sub_mb_pred_modes: u32,
        reserved7: u32,
        ref_idx_l0_0: u32,
        ref_idx_l0_1: u32,
        ref_idx_l0_2: u32,
        ref_idx_l0_3: u32,
        ref_idx_l1_0: u32,
        ref_idx_l1_1: u32,
        ref_idx_l1_2: u32,
        ref_idx_l1_3: u32,
    ) -> __BindgenBitfieldUnit<[u8; 12usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 12usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let sub_mb_shapes: u32 = unsafe { ::std::mem::transmute(sub_mb_shapes) };
            sub_mb_shapes as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let sub_mb_pred_modes: u32 = unsafe { ::std::mem::transmute(sub_mb_pred_modes) };
            sub_mb_pred_modes as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let reserved7: u32 = unsafe { ::std::mem::transmute(reserved7) };
            reserved7 as u64
        });
        __bindgen_bitfield_unit.set(32usize, 8u8, {
            let ref_idx_l0_0: u32 = unsafe { ::std::mem::transmute(ref_idx_l0_0) };
            ref_idx_l0_0 as u64
        });
        __bindgen_bitfield_unit.set(40usize, 8u8, {
            let ref_idx_l0_1: u32 = unsafe { ::std::mem::transmute(ref_idx_l0_1) };
            ref_idx_l0_1 as u64
        });
        __bindgen_bitfield_unit.set(48usize, 8u8, {
            let ref_idx_l0_2: u32 = unsafe { ::std::mem::transmute(ref_idx_l0_2) };
            ref_idx_l0_2 as u64
        });
        __bindgen_bitfield_unit.set(56usize, 8u8, {
            let ref_idx_l0_3: u32 = unsafe { ::std::mem::transmute(ref_idx_l0_3) };
            ref_idx_l0_3 as u64
        });
        __bindgen_bitfield_unit.set(64usize, 8u8, {
            let ref_idx_l1_0: u32 = unsafe { ::std::mem::transmute(ref_idx_l1_0) };
            ref_idx_l1_0 as u64
        });
        __bindgen_bitfield_unit.set(72usize, 8u8, {
            let ref_idx_l1_1: u32 = unsafe { ::std::mem::transmute(ref_idx_l1_1) };
            ref_idx_l1_1 as u64
        });
        __bindgen_bitfield_unit.set(80usize, 8u8, {
            let ref_idx_l1_2: u32 = unsafe { ::std::mem::transmute(ref_idx_l1_2) };
            ref_idx_l1_2 as u64
        });
        __bindgen_bitfield_unit.set(88usize, 8u8, {
            let ref_idx_l1_3: u32 = unsafe { ::std::mem::transmute(ref_idx_l1_3) };
            ref_idx_l1_3 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _VAEncFEIMBCodeH264__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _VAEncFEIMBCodeH264 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _VAEncFEIMBCodeH264 {
    #[inline]
    pub fn inter_mb_mode(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_inter_mb_mode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn mb_skip_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mb_skip_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved1(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn intra_mb_mode(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_intra_mb_mode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved2(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn field_mb_polarity_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_field_mb_polarity_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mb_type(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_mb_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn intra_mb_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_intra_mb_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn field_mb_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_field_mb_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn transform8x8_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_transform8x8_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved3(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dc_block_coded_cr_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dc_block_coded_cr_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dc_block_coded_cb_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dc_block_coded_cb_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dc_block_coded_y_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dc_block_coded_y_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved4(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_reserved4(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn horz_origin(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_horz_origin(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn vert_origin(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(40usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_vert_origin(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(40usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn cbp_y(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(48usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_cbp_y(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(48usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn cbp_cb(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(64usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_cbp_cb(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(64usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn cbp_cr(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(80usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_cbp_cr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(80usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn qp_prime_y(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(96usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_qp_prime_y(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(96usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved5(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(104usize, 17u8) as u32) }
    }
    #[inline]
    pub fn set_reserved5(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(104usize, 17u8, val as u64)
        }
    }
    #[inline]
    pub fn mb_skip_conv_disable(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(121usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mb_skip_conv_disable(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(121usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_last_mb(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(122usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_last_mb(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(122usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enable_coefficient_clamp(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(123usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enable_coefficient_clamp(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(123usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn direct8x8_pattern(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(124usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_direct8x8_pattern(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(124usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        inter_mb_mode: u32,
        mb_skip_flag: u32,
        reserved1: u32,
        intra_mb_mode: u32,
        reserved2: u32,
        field_mb_polarity_flag: u32,
        mb_type: u32,
        intra_mb_flag: u32,
        field_mb_flag: u32,
        transform8x8_flag: u32,
        reserved3: u32,
        dc_block_coded_cr_flag: u32,
        dc_block_coded_cb_flag: u32,
        dc_block_coded_y_flag: u32,
        reserved4: u32,
        horz_origin: u32,
        vert_origin: u32,
        cbp_y: u32,
        cbp_cb: u32,
        cbp_cr: u32,
        qp_prime_y: u32,
        reserved5: u32,
        mb_skip_conv_disable: u32,
        is_last_mb: u32,
        enable_coefficient_clamp: u32,
        direct8x8_pattern: u32,
    ) -> __BindgenBitfieldUnit<[u8; 16usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 16usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let inter_mb_mode: u32 = unsafe { ::std::mem::transmute(inter_mb_mode) };
            inter_mb_mode as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let mb_skip_flag: u32 = unsafe { ::std::mem::transmute(mb_skip_flag) };
            mb_skip_flag as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let reserved1: u32 = unsafe { ::std::mem::transmute(reserved1) };
            reserved1 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 2u8, {
            let intra_mb_mode: u32 = unsafe { ::std::mem::transmute(intra_mb_mode) };
            intra_mb_mode as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let reserved2: u32 = unsafe { ::std::mem::transmute(reserved2) };
            reserved2 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let field_mb_polarity_flag: u32 =
                unsafe { ::std::mem::transmute(field_mb_polarity_flag) };
            field_mb_polarity_flag as u64
        });
        __bindgen_bitfield_unit.set(8usize, 5u8, {
            let mb_type: u32 = unsafe { ::std::mem::transmute(mb_type) };
            mb_type as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let intra_mb_flag: u32 = unsafe { ::std::mem::transmute(intra_mb_flag) };
            intra_mb_flag as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let field_mb_flag: u32 = unsafe { ::std::mem::transmute(field_mb_flag) };
            field_mb_flag as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let transform8x8_flag: u32 = unsafe { ::std::mem::transmute(transform8x8_flag) };
            transform8x8_flag as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let reserved3: u32 = unsafe { ::std::mem::transmute(reserved3) };
            reserved3 as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let dc_block_coded_cr_flag: u32 =
                unsafe { ::std::mem::transmute(dc_block_coded_cr_flag) };
            dc_block_coded_cr_flag as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let dc_block_coded_cb_flag: u32 =
                unsafe { ::std::mem::transmute(dc_block_coded_cb_flag) };
            dc_block_coded_cb_flag as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let dc_block_coded_y_flag: u32 =
                unsafe { ::std::mem::transmute(dc_block_coded_y_flag) };
            dc_block_coded_y_flag as u64
        });
        __bindgen_bitfield_unit.set(20usize, 12u8, {
            let reserved4: u32 = unsafe { ::std::mem::transmute(reserved4) };
            reserved4 as u64
        });
        __bindgen_bitfield_unit.set(32usize, 8u8, {
            let horz_origin: u32 = unsafe { ::std::mem::transmute(horz_origin) };
            horz_origin as u64
        });
        __bindgen_bitfield_unit.set(40usize, 8u8, {
            let vert_origin: u32 = unsafe { ::std::mem::transmute(vert_origin) };
            vert_origin as u64
        });
        __bindgen_bitfield_unit.set(48usize, 16u8, {
            let cbp_y: u32 = unsafe { ::std::mem::transmute(cbp_y) };
            cbp_y as u64
        });
        __bindgen_bitfield_unit.set(64usize, 16u8, {
            let cbp_cb: u32 = unsafe { ::std::mem::transmute(cbp_cb) };
            cbp_cb as u64
        });
        __bindgen_bitfield_unit.set(80usize, 16u8, {
            let cbp_cr: u32 = unsafe { ::std::mem::transmute(cbp_cr) };
            cbp_cr as u64
        });
        __bindgen_bitfield_unit.set(96usize, 8u8, {
            let qp_prime_y: u32 = unsafe { ::std::mem::transmute(qp_prime_y) };
            qp_prime_y as u64
        });
        __bindgen_bitfield_unit.set(104usize, 17u8, {
            let reserved5: u32 = unsafe { ::std::mem::transmute(reserved5) };
            reserved5 as u64
        });
        __bindgen_bitfield_unit.set(121usize, 1u8, {
            let mb_skip_conv_disable: u32 = unsafe { ::std::mem::transmute(mb_skip_conv_disable) };
            mb_skip_conv_disable as u64
        });
        __bindgen_bitfield_unit.set(122usize, 1u8, {
            let is_last_mb: u32 = unsafe { ::std::mem::transmute(is_last_mb) };
            is_last_mb as u64
        });
        __bindgen_bitfield_unit.set(123usize, 1u8, {
            let enable_coefficient_clamp: u32 =
                unsafe { ::std::mem::transmute(enable_coefficient_clamp) };
            enable_coefficient_clamp as u64
        });
        __bindgen_bitfield_unit.set(124usize, 4u8, {
            let direct8x8_pattern: u32 = unsafe { ::std::mem::transmute(direct8x8_pattern) };
            direct8x8_pattern as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn reserved8(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_reserved8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn target_size_in_word(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_target_size_in_word(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn max_size_in_word(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_max_size_in_word(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_2(
        reserved8: u32,
        target_size_in_word: u32,
        max_size_in_word: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let reserved8: u32 = unsafe { ::std::mem::transmute(reserved8) };
            reserved8 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let target_size_in_word: u32 = unsafe { ::std::mem::transmute(target_size_in_word) };
            target_size_in_word as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let max_size_in_word: u32 = unsafe { ::std::mem::transmute(max_size_in_word) };
            max_size_in_word as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type VAEncFEIMBCodeH264 = _VAEncFEIMBCodeH264;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VAEncFEIDistortionH264 {
    pub inter_distortion: [u16; 16usize],
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
    pub reserved1: [u32; 2usize],
}
impl _VAEncFEIDistortionH264 {
    #[inline]
    pub fn best_inter_distortion(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_best_inter_distortion(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn best_intra_distortion(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_best_intra_distortion(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn colocated_mb_distortion(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_colocated_mb_distortion(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(48usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(48usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        best_inter_distortion: u32,
        best_intra_distortion: u32,
        colocated_mb_distortion: u32,
        reserved0: u32,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let best_inter_distortion: u32 =
                unsafe { ::std::mem::transmute(best_inter_distortion) };
            best_inter_distortion as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let best_intra_distortion: u32 =
                unsafe { ::std::mem::transmute(best_intra_distortion) };
            best_intra_distortion as u64
        });
        __bindgen_bitfield_unit.set(32usize, 16u8, {
            let colocated_mb_distortion: u32 =
                unsafe { ::std::mem::transmute(colocated_mb_distortion) };
            colocated_mb_distortion as u64
        });
        __bindgen_bitfield_unit.set(48usize, 16u8, {
            let reserved0: u32 = unsafe { ::std::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type VAEncFEIDistortionH264 = _VAEncFEIDistortionH264;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _VAStatsStatisticsParameterH264 {
    pub stats_params: VAStatsStatisticsParameter,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 16usize]>,
    pub reserved4: [u32; 2usize],
}
impl Default for _VAStatsStatisticsParameterH264 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _VAStatsStatisticsParameterH264 {
    #[inline]
    pub fn frame_qp(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_frame_qp(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn len_sp(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_len_sp(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn search_path(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_search_path(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn sub_mb_part_mask(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_sub_mb_part_mask(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn sub_pel_mode(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(39usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_sub_pel_mode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(39usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn inter_sad(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(41usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_inter_sad(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(41usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn intra_sad(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(43usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_intra_sad(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(43usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn adaptive_search(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(45usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_adaptive_search(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(45usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mv_predictor_ctrl(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(46usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_mv_predictor_ctrl(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(46usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn mb_qp(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(49usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mb_qp(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(49usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ft_enable(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(50usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ft_enable(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(50usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn intra_part_mask(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(51usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_intra_part_mask(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(51usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved1(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(56usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(56usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn ref_width(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(64usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_ref_width(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(64usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn ref_height(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(72usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_ref_height(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(72usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn search_window(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(80usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_search_window(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(80usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved2(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(84usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_reserved2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(84usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn disable_mv_output(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(96usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disable_mv_output(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(96usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn disable_statistics_output(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(97usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disable_statistics_output(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(97usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enable_8x8_statistics(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(98usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enable_8x8_statistics(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(98usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved3(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(99usize, 29u8) as u32) }
    }
    #[inline]
    pub fn set_reserved3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(99usize, 29u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        frame_qp: u32,
        len_sp: u32,
        search_path: u32,
        reserved0: u32,
        sub_mb_part_mask: u32,
        sub_pel_mode: u32,
        inter_sad: u32,
        intra_sad: u32,
        adaptive_search: u32,
        mv_predictor_ctrl: u32,
        mb_qp: u32,
        ft_enable: u32,
        intra_part_mask: u32,
        reserved1: u32,
        ref_width: u32,
        ref_height: u32,
        search_window: u32,
        reserved2: u32,
        disable_mv_output: u32,
        disable_statistics_output: u32,
        enable_8x8_statistics: u32,
        reserved3: u32,
    ) -> __BindgenBitfieldUnit<[u8; 16usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 16usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let frame_qp: u32 = unsafe { ::std::mem::transmute(frame_qp) };
            frame_qp as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let len_sp: u32 = unsafe { ::std::mem::transmute(len_sp) };
            len_sp as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let search_path: u32 = unsafe { ::std::mem::transmute(search_path) };
            search_path as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let reserved0: u32 = unsafe { ::std::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(32usize, 7u8, {
            let sub_mb_part_mask: u32 = unsafe { ::std::mem::transmute(sub_mb_part_mask) };
            sub_mb_part_mask as u64
        });
        __bindgen_bitfield_unit.set(39usize, 2u8, {
            let sub_pel_mode: u32 = unsafe { ::std::mem::transmute(sub_pel_mode) };
            sub_pel_mode as u64
        });
        __bindgen_bitfield_unit.set(41usize, 2u8, {
            let inter_sad: u32 = unsafe { ::std::mem::transmute(inter_sad) };
            inter_sad as u64
        });
        __bindgen_bitfield_unit.set(43usize, 2u8, {
            let intra_sad: u32 = unsafe { ::std::mem::transmute(intra_sad) };
            intra_sad as u64
        });
        __bindgen_bitfield_unit.set(45usize, 1u8, {
            let adaptive_search: u32 = unsafe { ::std::mem::transmute(adaptive_search) };
            adaptive_search as u64
        });
        __bindgen_bitfield_unit.set(46usize, 3u8, {
            let mv_predictor_ctrl: u32 = unsafe { ::std::mem::transmute(mv_predictor_ctrl) };
            mv_predictor_ctrl as u64
        });
        __bindgen_bitfield_unit.set(49usize, 1u8, {
            let mb_qp: u32 = unsafe { ::std::mem::transmute(mb_qp) };
            mb_qp as u64
        });
        __bindgen_bitfield_unit.set(50usize, 1u8, {
            let ft_enable: u32 = unsafe { ::std::mem::transmute(ft_enable) };
            ft_enable as u64
        });
        __bindgen_bitfield_unit.set(51usize, 5u8, {
            let intra_part_mask: u32 = unsafe { ::std::mem::transmute(intra_part_mask) };
            intra_part_mask as u64
        });
        __bindgen_bitfield_unit.set(56usize, 8u8, {
            let reserved1: u32 = unsafe { ::std::mem::transmute(reserved1) };
            reserved1 as u64
        });
        __bindgen_bitfield_unit.set(64usize, 8u8, {
            let ref_width: u32 = unsafe { ::std::mem::transmute(ref_width) };
            ref_width as u64
        });
        __bindgen_bitfield_unit.set(72usize, 8u8, {
            let ref_height: u32 = unsafe { ::std::mem::transmute(ref_height) };
            ref_height as u64
        });
        __bindgen_bitfield_unit.set(80usize, 4u8, {
            let search_window: u32 = unsafe { ::std::mem::transmute(search_window) };
            search_window as u64
        });
        __bindgen_bitfield_unit.set(84usize, 12u8, {
            let reserved2: u32 = unsafe { ::std::mem::transmute(reserved2) };
            reserved2 as u64
        });
        __bindgen_bitfield_unit.set(96usize, 1u8, {
            let disable_mv_output: u32 = unsafe { ::std::mem::transmute(disable_mv_output) };
            disable_mv_output as u64
        });
        __bindgen_bitfield_unit.set(97usize, 1u8, {
            let disable_statistics_output: u32 =
                unsafe { ::std::mem::transmute(disable_statistics_output) };
            disable_statistics_output as u64
        });
        __bindgen_bitfield_unit.set(98usize, 1u8, {
            let enable_8x8_statistics: u32 =
                unsafe { ::std::mem::transmute(enable_8x8_statistics) };
            enable_8x8_statistics as u64
        });
        __bindgen_bitfield_unit.set(99usize, 29u8, {
            let reserved3: u32 = unsafe { ::std::mem::transmute(reserved3) };
            reserved3 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type VAStatsStatisticsParameterH264 = _VAStatsStatisticsParameterH264;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VAStatsStatisticsH264 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 16usize]>,
    pub sum_coef: u32,
    pub _bitfield_align_2: [u32; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub variance_16x16: u32,
    pub variance_8x8: [u32; 4usize],
    pub pixel_average_16x16: u32,
    pub pixel_average_8x8: [u32; 4usize],
}
impl _VAStatsStatisticsH264 {
    #[inline]
    pub fn best_inter_distortion0(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_best_inter_distortion0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn inter_mode0(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_inter_mode0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn best_inter_distortion1(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_best_inter_distortion1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn inter_mode1(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(48usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_inter_mode1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(48usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn best_intra_distortion(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(64usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_best_intra_distortion(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(64usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn intra_mode(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(80usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_intra_mode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(80usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn num_non_zero_coef(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(96usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_num_non_zero_coef(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(96usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(112usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(112usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        best_inter_distortion0: u32,
        inter_mode0: u32,
        best_inter_distortion1: u32,
        inter_mode1: u32,
        best_intra_distortion: u32,
        intra_mode: u32,
        num_non_zero_coef: u32,
        reserved0: u32,
    ) -> __BindgenBitfieldUnit<[u8; 16usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 16usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let best_inter_distortion0: u32 =
                unsafe { ::std::mem::transmute(best_inter_distortion0) };
            best_inter_distortion0 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let inter_mode0: u32 = unsafe { ::std::mem::transmute(inter_mode0) };
            inter_mode0 as u64
        });
        __bindgen_bitfield_unit.set(32usize, 16u8, {
            let best_inter_distortion1: u32 =
                unsafe { ::std::mem::transmute(best_inter_distortion1) };
            best_inter_distortion1 as u64
        });
        __bindgen_bitfield_unit.set(48usize, 16u8, {
            let inter_mode1: u32 = unsafe { ::std::mem::transmute(inter_mode1) };
            inter_mode1 as u64
        });
        __bindgen_bitfield_unit.set(64usize, 16u8, {
            let best_intra_distortion: u32 =
                unsafe { ::std::mem::transmute(best_intra_distortion) };
            best_intra_distortion as u64
        });
        __bindgen_bitfield_unit.set(80usize, 16u8, {
            let intra_mode: u32 = unsafe { ::std::mem::transmute(intra_mode) };
            intra_mode as u64
        });
        __bindgen_bitfield_unit.set(96usize, 16u8, {
            let num_non_zero_coef: u32 = unsafe { ::std::mem::transmute(num_non_zero_coef) };
            num_non_zero_coef as u64
        });
        __bindgen_bitfield_unit.set(112usize, 16u8, {
            let reserved0: u32 = unsafe { ::std::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn mb_is_flat(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mb_is_flat(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved1(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_2(mb_is_flat: u32, reserved1: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let mb_is_flat: u32 = unsafe { ::std::mem::transmute(mb_is_flat) };
            mb_is_flat as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let reserved1: u32 = unsafe { ::std::mem::transmute(reserved1) };
            reserved1 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type VAStatsStatisticsH264 = _VAStatsStatisticsH264;
pub const _VAProcFilterType_VAProcFilterNone: _VAProcFilterType = 0;
pub const _VAProcFilterType_VAProcFilterNoiseReduction: _VAProcFilterType = 1;
pub const _VAProcFilterType_VAProcFilterDeinterlacing: _VAProcFilterType = 2;
pub const _VAProcFilterType_VAProcFilterSharpening: _VAProcFilterType = 3;
pub const _VAProcFilterType_VAProcFilterColorBalance: _VAProcFilterType = 4;
pub const _VAProcFilterType_VAProcFilterSkinToneEnhancement: _VAProcFilterType = 5;
pub const _VAProcFilterType_VAProcFilterTotalColorCorrection: _VAProcFilterType = 6;
pub const _VAProcFilterType_VAProcFilterHVSNoiseReduction: _VAProcFilterType = 7;
pub const _VAProcFilterType_VAProcFilterHighDynamicRangeToneMapping: _VAProcFilterType = 8;
pub const _VAProcFilterType_VAProcFilter3DLUT: _VAProcFilterType = 9;
pub const _VAProcFilterType_VAProcFilterCount: _VAProcFilterType = 10;
pub type _VAProcFilterType = ::std::os::raw::c_uint;
pub use self::_VAProcFilterType as VAProcFilterType;
pub const _VAProcColorStandardType_VAProcColorStandardNone: _VAProcColorStandardType = 0;
pub const _VAProcColorStandardType_VAProcColorStandardBT601: _VAProcColorStandardType = 1;
pub const _VAProcColorStandardType_VAProcColorStandardBT709: _VAProcColorStandardType = 2;
pub const _VAProcColorStandardType_VAProcColorStandardBT470M: _VAProcColorStandardType = 3;
pub const _VAProcColorStandardType_VAProcColorStandardBT470BG: _VAProcColorStandardType = 4;
pub const _VAProcColorStandardType_VAProcColorStandardSMPTE170M: _VAProcColorStandardType = 5;
pub const _VAProcColorStandardType_VAProcColorStandardSMPTE240M: _VAProcColorStandardType = 6;
pub const _VAProcColorStandardType_VAProcColorStandardGenericFilm: _VAProcColorStandardType = 7;
pub const _VAProcColorStandardType_VAProcColorStandardSRGB: _VAProcColorStandardType = 8;
pub const _VAProcColorStandardType_VAProcColorStandardSTRGB: _VAProcColorStandardType = 9;
pub const _VAProcColorStandardType_VAProcColorStandardXVYCC601: _VAProcColorStandardType = 10;
pub const _VAProcColorStandardType_VAProcColorStandardXVYCC709: _VAProcColorStandardType = 11;
pub const _VAProcColorStandardType_VAProcColorStandardBT2020: _VAProcColorStandardType = 12;
pub const _VAProcColorStandardType_VAProcColorStandardExplicit: _VAProcColorStandardType = 13;
pub const _VAProcColorStandardType_VAProcColorStandardCount: _VAProcColorStandardType = 14;
pub type _VAProcColorStandardType = ::std::os::raw::c_uint;
pub use self::_VAProcColorStandardType as VAProcColorStandardType;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _VAProcPipelineCaps {
    pub pipeline_flags: u32,
    pub filter_flags: u32,
    pub num_forward_references: u32,
    pub num_backward_references: u32,
    pub input_color_standards: *mut VAProcColorStandardType,
    pub num_input_color_standards: u32,
    pub output_color_standards: *mut VAProcColorStandardType,
    pub num_output_color_standards: u32,
    pub rotation_flags: u32,
    pub blend_flags: u32,
    pub mirror_flags: u32,
    pub num_additional_outputs: u32,
    pub num_input_pixel_formats: u32,
    pub input_pixel_format: *mut u32,
    pub num_output_pixel_formats: u32,
    pub output_pixel_format: *mut u32,
    pub max_input_width: u32,
    pub max_input_height: u32,
    pub min_input_width: u32,
    pub min_input_height: u32,
    pub max_output_width: u32,
    pub max_output_height: u32,
    pub min_output_width: u32,
    pub min_output_height: u32,
    pub va_reserved: [u32; 14usize],
}
impl Default for _VAProcPipelineCaps {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type VAProcPipelineCaps = _VAProcPipelineCaps;
extern "C" {
    pub fn vaQueryVideoProcFilters(
        dpy: VADisplay,
        context: VAContextID,
        filters: *mut VAProcFilterType,
        num_filters: *mut ::std::os::raw::c_uint,
    ) -> VAStatus;
}
extern "C" {
    pub fn vaQueryVideoProcFilterCaps(
        dpy: VADisplay,
        context: VAContextID,
        type_: VAProcFilterType,
        filter_caps: *mut ::std::os::raw::c_void,
        num_filter_caps: *mut ::std::os::raw::c_uint,
    ) -> VAStatus;
}
extern "C" {
    pub fn vaQueryVideoProcPipelineCaps(
        dpy: VADisplay,
        context: VAContextID,
        filters: *mut VABufferID,
        num_filters: ::std::os::raw::c_uint,
        pipeline_caps: *mut VAProcPipelineCaps,
    ) -> VAStatus;
}
pub type VAProtectedSessionID = VAGenericID;
extern "C" {
    pub fn vaCreateProtectedSession(
        dpy: VADisplay,
        config_id: VAConfigID,
        protected_session: *mut VAProtectedSessionID,
    ) -> VAStatus;
}
extern "C" {
    pub fn vaDestroyProtectedSession(
        dpy: VADisplay,
        protected_session: VAProtectedSessionID,
    ) -> VAStatus;
}
extern "C" {
    pub fn vaAttachProtectedSession(
        dpy: VADisplay,
        id: VAGenericID,
        protected_session: VAProtectedSessionID,
    ) -> VAStatus;
}
extern "C" {
    pub fn vaDetachProtectedSession(dpy: VADisplay, id: VAGenericID) -> VAStatus;
}
extern "C" {
    pub fn vaProtectedSessionExecute(
        dpy: VADisplay,
        protected_session: VAProtectedSessionID,
        buf_id: VABufferID,
    ) -> VAStatus;
}
extern "C" {
    pub fn vaGetDisplayDRM(fd: ::std::os::raw::c_int) -> VADisplay;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VADRMPRIMESurfaceDescriptor {
    pub fourcc: u32,
    pub width: u32,
    pub height: u32,
    pub num_objects: u32,
    pub objects: [_VADRMPRIMESurfaceDescriptor__bindgen_ty_1; 4usize],
    pub num_layers: u32,
    pub layers: [_VADRMPRIMESurfaceDescriptor__bindgen_ty_2; 4usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VADRMPRIMESurfaceDescriptor__bindgen_ty_1 {
    pub fd: ::std::os::raw::c_int,
    pub size: u32,
    pub drm_format_modifier: u64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VADRMPRIMESurfaceDescriptor__bindgen_ty_2 {
    pub drm_format: u32,
    pub num_planes: u32,
    pub object_index: [u32; 4usize],
    pub offset: [u32; 4usize],
    pub pitch: [u32; 4usize],
}
pub type VADRMPRIMESurfaceDescriptor = _VADRMPRIMESurfaceDescriptor;
